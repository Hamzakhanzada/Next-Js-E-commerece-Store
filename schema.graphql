directive @auth on FIELD_DEFINITION | OBJECT

# Queries return all requested data, without any side effects
type Query {
  # A test query
  ping: String!

  # Returns the primary shop for the domain
  primaryShop: Shop

  # Returns the ID of the primary shop for the domain
  primaryShopId: ID

  # Returns a shop by ID
  shop(
    # The shop ID
    id: ID!
  ): Shop

  # Returns a shop by slug
  shopBySlug(
    # The shop slug
    slug: String!
  ): Shop

  #
  shops(
    # Shop IDs to filter by
    shopIds: [ID]

    # Return only results that come after this cursor. Use this with `first` to specify the number of results to return.
    after: ConnectionCursor

    # Return only results that come before this cursor. Use this with `last` to specify the number of results to return.
    before: ConnectionCursor

    # Return at most this many results. This parameter may be used with either `after` or `offset` parameters.
    first: ConnectionLimitInt

    # Return at most this many results. This parameter may be used with the `before` parameter.
    last: ConnectionLimitInt

    # Return only results that come after the Nth result. This parameter may be used with the `first` parameter.
    offset: Int

    # Return results sorted in this order
    sortOrder: SortOrder = asc

    # By default, groups are sorted by when they were created, oldest first. Set this to sort by one of the other allowed fields
    sortBy: GroupSortByField = createdAt
  ): ShopConnection

  # Returns app settings that are not shop specific. Plugins extend the GlobalSettings type to support
  # whatever settings they need.
  globalSettings: GlobalSettings!

  # Returns app settings for a specific shop. Plugins extend the ShopSettings type to support
  # whatever settings they need.
  shopSettings(
    # The shop to get app settings for
    shopId: ID!
  ): ShopSettings!

  # Get e-mail jobs for a given set of shops
  emailJobs(
    # The shop IDs to get e-mail jobs for
    shopIds: [ID]!

    # Return only results that come after this cursor. Use this with `first` to specify the number of results to return.
    after: ConnectionCursor

    # Return only results that come before this cursor. Use this with `last` to specify the number of results to return.
    before: ConnectionCursor

    # Return at most this many results. This parameter may be used with either `after` or `offset` parameters.
    first: ConnectionLimitInt

    # Return at most this many results. This parameter may be used with the `before` parameter.
    last: ConnectionLimitInt

    # Return only results that come after the Nth result. This parameter may be used with the `first` parameter.
    offset: Int
  ): EmailJobConnection!

  # Get a list of errors and suggested properly formatted addresses for an address. If no address
  # validation service is active for the shop, this will return as if the address is valid even
  # though no check actually occurred.
  addressValidation(
    # Address to validate
    address: AddressInput!

    # Shop to use for determining what validation service to use
    shopId: ID!
  ): AddressValidationResults!

  # Get a full list of all registered address validation services
  addressValidationServices: [AddressValidationService]!

  # Returns a list of defined address validation rules for a shop
  addressValidationRules(
    # Return only results that come after this cursor. Use this with `first` to specify the number of results to return.
    after: ConnectionCursor

    # Return only results that come before this cursor. Use this with `last` to specify the number of results to return.
    before: ConnectionCursor

    # Return at most this many results. This parameter may be used with either `after` or `offset` parameters.
    first: ConnectionLimitInt

    # Return at most this many results. This parameter may be used with the `before` parameter.
    last: ConnectionLimitInt

    # Return only results that come after the Nth result. This parameter may be used with the `first` parameter.
    offset: Int

    # An optional list of service names, to get only rules that specify one of these services
    serviceNames: [String]

    # ID of the shop for which to get defined address validation rules
    shopId: ID!

    # Return results sorted in this order
    sortOrder: SortOrder = asc

    # By default, rules are sorted by when they were created, oldest first. Set this to sort by one of the other allowed fields
    sortBy: AddressValidationRuleSortByField = createdAt
  ): AddressValidationRuleConnection!

  # SystemInformation object
  systemInformation(
    # Shop ID to use for shop-specific system information
    shopId: ID!
  ): SystemInformation!

  # Retrieves a list of email templates
  emailTemplates(
    # The shopId to which email templates belong to
    shopId: ID!

    # Return only results that come after this cursor. Use this with `first` to specify the number of results to return.
    after: ConnectionCursor

    # Return only results that come before this cursor. Use this with `last` to specify the number of results to return.
    before: ConnectionCursor

    # Return at most this many results. This parameter may be used with either `after` or `offset` parameters.
    first: ConnectionLimitInt

    # Return at most this many results. This parameter may be used with the `before` parameter.
    last: ConnectionLimitInt

    # Return only results that come after the Nth result. This parameter may be used with the `first` parameter.
    offset: Int
  ): TemplateConnection

  # Returns the account with the provided ID
  account(
    # The account ID
    id: ID!
  ): Account

  # Returns accounts optionally filtered by account groups
  accounts(
    # Return only accounts in any of these groups
    groupIds: [ID]

    # Return accounts that aren't in any groups
    notInAnyGroups: Boolean

    # Return only results that come after this cursor. Use this with `first` to specify the number of results to return.
    after: ConnectionCursor

    # Return only results that come before this cursor. Use this with `last` to specify the number of results to return.
    before: ConnectionCursor

    # Return at most this many results. This parameter may be used with either `after` or `offset` parameters.
    first: ConnectionLimitInt

    # Return at most this many results. This parameter may be used with the `before` parameter.
    last: ConnectionLimitInt

    # Return only results that come after the Nth result. This parameter may be used with the `first` parameter.
    offset: Int

    # Return results sorted in this order
    sortOrder: SortOrder = asc

    # By default, groups are sorted by when they were created, oldest first. Set this to sort by one of the other allowed fields
    sortBy: AccountSortByField = createdAt
  ): AccountConnection!

  # Returns customer accounts
  customers(
    # Return only results that come after this cursor. Use this with `first` to specify the number of results to return.
    after: ConnectionCursor

    # Return only results that come before this cursor. Use this with `last` to specify the number of results to return.
    before: ConnectionCursor

    # Return at most this many results. This parameter may be used with either `after` or `offset` parameters.
    first: ConnectionLimitInt

    # Return at most this many results. This parameter may be used with the `before` parameter.
    last: ConnectionLimitInt

    # Return only results that come after the Nth result. This parameter may be used with the `first` parameter.
    offset: Int

    # Return results sorted in this order
    sortOrder: SortOrder = asc

    # By default, groups are sorted by when they were created, oldest first. Set this to sort by one of the other allowed fields
    sortBy: AccountSortByField = createdAt
  ): AccountConnection!

  # Returns the account for the authenticated user
  viewer: Account

  # Returns a single group by ID.
  group(
    # The group ID
    id: ID!
  ): Group

  # Returns a list of groups for the shop with ID `shopId`, as a Relay-compatible connection.
  groups(
    # Return groups for this shop
    shopId: ID!

    # Return only results that come after this cursor. Use this with `first` to specify the number of results to return.
    after: ConnectionCursor

    # Return only results that come before this cursor. Use this with `last` to specify the number of results to return.
    before: ConnectionCursor

    # Return at most this many results. This parameter may be used with either `after` or `offset` parameters.
    first: ConnectionLimitInt

    # Return at most this many results. This parameter may be used with the `before` parameter.
    last: ConnectionLimitInt

    # Return only results that come after the Nth result. This parameter may be used with the `first` parameter.
    offset: Int

    # Return results sorted in this order
    sortOrder: SortOrder = asc

    # By default, groups are sorted by when they were created, oldest first. Set this to sort by one of the other allowed fields
    sortBy: GroupSortByField = createdAt
  ): GroupConnection

  # Returns all pending staff member invitations
  invitations(
    # The shop IDs to get invitations for
    shopIds: [ID]

    # Return only results that come after this cursor. Use this with `first` to specify the number of results to return.
    after: ConnectionCursor

    # Return only results that come before this cursor. Use this with `last` to specify the number of results to return.
    before: ConnectionCursor

    # Return at most this many results. This parameter may be used with either `after` or `offset` parameters.
    first: ConnectionLimitInt

    # Return at most this many results. This parameter may be used with the `before` parameter.
    last: ConnectionLimitInt

    # Return only results that come after the Nth result. This parameter may be used with the `first` parameter.
    offset: Int

    # Return results sorted in this order
    sortOrder: SortOrder = asc

    # By default, groups are sorted by when they were created, oldest first. Set this to sort by one of the other allowed fields
    sortBy: AccountSortByField = createdAt
  ): InvitationConnection!

  # Returns a paged list of all roles associated with a shop
  roles(
    # Return valid roles for this shop
    shopId: ID!

    # Return only results that come after this cursor. Use this with `first` to specify the number of results to return.
    after: ConnectionCursor

    # Return only results that come before this cursor. Use this with `last` to specify the number of results to return.
    before: ConnectionCursor

    # Return at most this many results. This parameter may be used with either `after` or `offset` parameters.
    first: ConnectionLimitInt

    # Return at most this many results. This parameter may be used with the `before` parameter.
    last: ConnectionLimitInt

    # Return only results that come after the Nth result. This parameter may be used with the `first` parameter.
    offset: Int

    # Return results sorted in this order
    sortOrder: SortOrder = asc

    # By default, roles are sorted alphabetically by name. Set this to sort by one of the other allowed fields
    sortBy: RoleSortByField = name
  ): RoleConnection

  # Query for a single Product
  product(
    # Product ID
    productId: ID!

    # Shop ID
    shopId: ID!
  ): Product

  # Query for a list of Products
  products(
    # Filter by archived
    isArchived: Boolean

    # Filter by visibility
    isVisible: Boolean

    # Filter by metafield key
    metafieldKey: String

    # Filter by metafield value
    metafieldValue: String

    # Filter by price range maximum value
    priceMax: Float

    # Filter by price range minimum value
    priceMin: Float

    # List of product IDs to filter by
    productIds: [ID]

    # Regex metch query string
    query: String

    # List of shop IDs to filter by
    shopIds: [ID]!

    # List of tag ids to filter by
    tagIds: [ID]

    # Return only results that come after this cursor. Use this with `first` to specify the number of results to return.
    after: ConnectionCursor

    # Return only results that come before this cursor. Use this with `last` to specify the number of results to return.
    before: ConnectionCursor

    # Return at most this many results. This parameter may be used with either `after` or `offset` parameters.
    first: ConnectionLimitInt

    # Return at most this many results. This parameter may be used with the `before` parameter.
    last: ConnectionLimitInt

    # Return only results that come after the Nth result. This parameter may be used with the `first` parameter.
    offset: Int

    # Return results sorted in this order
    sortOrder: SortOrder = desc

    # By default, products are sorted by createdAt. Set this to sort by one of the other allowed fields
    sortBy: ProductSortByField = createdAt
  ): ProductConnection

  # Gets items from a shop catalog
  catalogItems(
    # Provide a list of shop IDs from which you want to get catalog items
    shopIds: [ID]!

    # Optionally provide a list of tag IDs to further filter the item list
    tagIds: [ID]

    # Additional filters to apply
    booleanFilters: [CatalogBooleanFilter]

    # Optional text search query
    searchQuery: String

    # Return only results that come after this cursor. Use this with `first` to specify the number of results to return.
    after: ConnectionCursor

    # Return only results that come before this cursor. Use this with `last` to specify the number of results to return.
    before: ConnectionCursor

    # Return at most this many results. This parameter may be used with either `after` or `offset` parameters.
    first: ConnectionLimitInt

    # Return at most this many results. This parameter may be used with the `before` parameter.
    last: ConnectionLimitInt

    # Return only results that come after the Nth result. This parameter may be used with the `first` parameter.
    offset: Int

    # Return results sorted in this order
    sortOrder: SortOrder = desc

    # Provide a Currency code if sortBy is minPrice
    sortByPriceCurrencyCode: String

    # By default, items are sorted by when they were last updated, most recently updated first. Set this to sort by one of the other allowed fields
    sortBy: CatalogItemSortByField = updatedAt
  ): CatalogItemConnection

  # Gets product from catalog
  catalogItemProduct(
    # ID of the shop that owns the catalog product. Not required but highly recommended if you
    # have multiple shops and `slugOrId` is a slug because slugs are unique only within a shop.
    shopId: ID

    # Provide either a product ID or slug
    slugOrId: String
  ): CatalogItemProduct

  # Gets an array of all vendors
  vendors(
    # Optionally provide a list of shop IDs from which you want to get the vendors
    shopIds: [ID]

    # Optionally provide a list of tag IDs to further filter the vendors
    tagIds: [ID]

    # Return only results that come after this cursor. Use this with `first` to specify the number of results to return.
    after: ConnectionCursor

    # Return only results that come before this cursor. Use this with `last` to specify the number of results to return.
    before: ConnectionCursor

    # Return at most this many results. This parameter may be used with either `after` or `offset` parameters.
    first: ConnectionLimitInt

    # Return at most this many results. This parameter may be used with the `before` parameter.
    last: ConnectionLimitInt

    # Return only results that come after the Nth result. This parameter may be used with the `first` parameter.
    offset: Int

    # Return results sorted in this order
    sortOrder: SortOrder = asc
  ): VendorConnection

  # Returns a list of product in a tag
  productsByTagId(
    # Shop that owns the tag
    shopId: ID!

    # The tag ID
    tagId: ID!

    # Regex match query string, for product title
    query: String

    # Return only results that come after this cursor. Use this with `first` to specify the number of results to return.
    after: ConnectionCursor

    # Return only results that come before this cursor. Use this with `last` to specify the number of results to return.
    before: ConnectionCursor

    # Return at most this many results. This parameter may be used with either `after` or `offset` parameters.
    first: ConnectionLimitInt

    # Return at most this many results. This parameter may be used with the `before` parameter.
    last: ConnectionLimitInt

    # Return only results that come after the Nth result. This parameter may be used with the `first` parameter.
    offset: Int
  ): TagProductConnection!

  # Returns a tag from a provided tag ID or slug. Tags with isVisible set to false are excluded by default.
  tag(
    # Slug or ID of Tag
    slugOrId: String!

    # The shop to which this tag belongs
    shopId: ID!

    # Set to true if you want to include tags that have isVisible set to false
    shouldIncludeInvisible: Boolean = false
  ): Tag

  # Returns a paged list of tags for a shop. You must include a shopId when querying.
  tags(
    # Only tags associated with this shop will be returned
    shopId: ID!

    # If provided, this query will do a regex search using the provided filter data, and return only tags that match
    filter: String

    # Tags to exclude from results
    excludedTagIds: [ID]

    # If set, the query will return only top-level tags or only non-top-level tags. By default, both types of tags are returned.
    isTopLevel: Boolean

    # Set to true if you want soft deleted tags to be included in the response
    shouldIncludeDeleted: Boolean = false

    # Set to true if you want to include tags that have isVisible set to false
    shouldIncludeInvisible: Boolean = false

    # Return only results that come after this cursor. Use this with `first` to specify the number of results to return.
    after: ConnectionCursor

    # Return only results that come before this cursor. Use this with `last` to specify the number of results to return.
    before: ConnectionCursor

    # Return at most this many results. This parameter may be used with either `after` or `offset` parameters.
    first: ConnectionLimitInt

    # Return at most this many results. This parameter may be used with the `before` parameter.
    last: ConnectionLimitInt

    # Return only results that come after the Nth result. This parameter may be used with the `first` parameter.
    offset: Int

    # Return results sorted in this order
    sortOrder: SortOrder = asc

    # By default, tags are sorted by position. Set this to sort by one of the other allowed fields
    sortBy: TagSortByField = position
  ): TagConnection

  # Get the SimpleInventory info for a product configuration. Returns `null` if `updateSimpleInventory`
  # has never been called for this product configuration.
  simpleInventory(
    # ID of the shop that owns the product
    shopId: ID!

    # The product configuration for which you want inventory info
    productConfiguration: ProductConfigurationInput!
  ): SimpleInventoryInfo

  # Finds a cart by the cart ID and anonymous cart token.
  anonymousCartByCartId(
    # The cart ID. Must be an anonymous cart (that is, one with no linked account).
    cartId: ID!

    # A valid anonymous cart access cartToken for this cart. This is returned when you create
    # an anonymous cart and should be stored securely in storefront client storage.
    cartToken: String!
  ): Cart

  # Find a cart for a given account ID.
  accountCartByAccountId(
    # Account that owns the cart
    accountId: ID!

    # Shop that owns the cart
    shopId: ID!
  ): Cart

  # Get an order by its ID
  orderById(
    # The order ID
    id: ID!

    # The shop that owns the order
    shopId: ID!

    # A valid anonymous access token for this order. Required if the order is not linked with an account.
    token: String
  ): Order

  # Get all orders for a single account, optionally limited to certain shop IDs and certain orderStatus
  orders(
    # Filters to apply to a list of orders
    filters: OrderFilterInput

    # Provide a list of shop IDs from which you want to get orders from
    shopIds: [ID]

    # Return only results that come after this cursor. Use this with `first` to specify the number of results to return.
    after: ConnectionCursor

    # Return only results that come before this cursor. Use this with `last` to specify the number of results to return.
    before: ConnectionCursor

    # Return at most this many results. This parameter may be used with either `after` or `offset` parameters.
    first: ConnectionLimitInt

    # Return at most this many results. This parameter may be used with the `before` parameter.
    last: ConnectionLimitInt

    # Return only results that come after the Nth result. This parameter may be used with the `first` parameter.
    offset: Int

    # Return results sorted in this order
    sortOrder: SortOrder = desc

    # By default, orders are sorted by when they were created, newest first. Set this to sort by one of the other allowed fields
    sortBy: OrdersSortByField = createdAt
  ): OrderConnection!

  # Get all orders for a single account, optionally limited to certain shop IDs and certain orderStatus
  ordersByAccountId(
    # Limit to orders placed by this account
    accountId: ID!

    # Limit to orders with one of these statuses
    orderStatus: [String]

    # Limit to orders owned by one of these shops
    shopIds: [ID]!

    # Return only results that come after this cursor. Use this with `first` to specify the number of results to return.
    after: ConnectionCursor

    # Return only results that come before this cursor. Use this with `last` to specify the number of results to return.
    before: ConnectionCursor

    # Return at most this many results. This parameter may be used with either `after` or `offset` parameters.
    first: ConnectionLimitInt

    # Return at most this many results. This parameter may be used with the `before` parameter.
    last: ConnectionLimitInt

    # Return only results that come after the Nth result. This parameter may be used with the `first` parameter.
    offset: Int

    # Return results sorted in this order
    sortOrder: SortOrder = desc

    # By default, orders are sorted by when they were created, newest first. Set this to sort by one of the other allowed fields
    sortBy: OrdersByAccountIdSortByField = createdAt
  ): OrdersByAccountIdConnection!

  # Get an order by its reference ID (the ID shown to customers)
  orderByReferenceId(
    # The order reference ID (the ID shown to customers)
    id: ID!

    # The shop that owns the order
    shopId: ID!

    # A valid anonymous access token for this order. Required if the order is not linked with an account.
    token: String
  ): Order

  # Get refunds applied to an order by order ID
  refunds(
    # The order ID
    orderId: ID!

    # The shop that owns the order
    shopId: ID!

    # A valid anonymous access token for this order. Required if the order is not linked with an account.
    token: String
  ): [Refund]

  # Get refunds applied to a specific payment by payment ID
  refundsByPaymentId(
    # The order ID
    orderId: ID!

    # The ID of one of the payments made for this order
    paymentId: ID!

    # The shop that owns the order
    shopId: ID!

    # A valid anonymous access token for this order. Required if the order is not linked with an account.
    token: String
  ): [Refund]

  # Get a list of all payment methods available during a checkout. This may filter by auth,
  # active/inactive, IP/region, shop, etc. To get the full list, use the `paymentMethods`
  # query with proper authorization.
  availablePaymentMethods(
    # ID of the shop for which the order will be placed
    shopId: ID!
  ): [PaymentMethod]!

  # Get a full list of all payment methods
  paymentMethods(
    # The shop to get payment methods for
    shopId: ID!
  ): [PaymentMethod]!

  # Gets discount codes
  discountCodes(
    # Provide a shop ID from which you want to get discount codes
    shopId: ID!

    # Filters to apply to a discount codes query
    filters: DiscountCodeFilterInput

    # Return only results that come after this cursor. Use this with `first` to specify the number of results to return.
    after: ConnectionCursor

    # Return only results that come before this cursor. Use this with `last` to specify the number of results to return.
    before: ConnectionCursor

    # Return at most this many results. This parameter may be used with either `after` or `offset` parameters.
    first: ConnectionLimitInt

    # Return at most this many results. This parameter may be used with the `before` parameter.
    last: ConnectionLimitInt

    # Return only results that come after the Nth result. This parameter may be used with the `first` parameter.
    offset: Int
  ): DiscountCodeConnection

  # Get the full list of surcharges.
  surcharges(
    # ID of shop to get surcharges for
    shopId: ID!

    # Return only results that come after this cursor. Use this with `first` to specify the number of results to return.
    after: ConnectionCursor

    # Return only results that come before this cursor. Use this with `last` to specify the number of results to return.
    before: ConnectionCursor

    # Return at most this many results. This parameter may be used with either `after` or `offset` parameters.
    first: ConnectionLimitInt

    # Return at most this many results. This parameter may be used with the `before` parameter.
    last: ConnectionLimitInt

    # Return only results that come after the Nth result. This parameter may be used with the `first` parameter.
    offset: Int

    # Return results sorted in this order
    sortOrder: SortOrder = desc

    # By default, surcharges are sorted by when they were created, newest first. Set this to sort by one of the other allowed fields
    sortBy: SurchargeSortByField = createdAt
  ): SurchargeConnection!

  # Get a single surcharge definition by its ID
  surchargeById(
    # ID of shop that owns the surcharge definition
    shopId: ID!

    # The surcharge ID
    surchargeId: ID!
  ): Surcharge

  # Get a flat rate fulfillment method
  flatRateFulfillmentMethod(
    # Fulfillment method id
    methodId: ID!

    # Shop ID
    shopId: ID!
  ): FlatRateFulfillmentMethod!

  # Get a flat rate fulfillment methods
  flatRateFulfillmentMethods(
    # Shop ID
    shopId: ID!

    # Return only results that come after this cursor. Use this with `first` to specify the number of results to return.
    after: ConnectionCursor

    # Return only results that come before this cursor. Use this with `last` to specify the number of results to return.
    before: ConnectionCursor

    # Return at most this many results. This parameter may be used with either `after` or `offset` parameters.
    first: ConnectionLimitInt

    # Return at most this many results. This parameter may be used with the `before` parameter.
    last: ConnectionLimitInt

    # Return only results that come after the Nth result. This parameter may be used with the `first` parameter.
    offset: Int
  ): FlatRateFulfillmentMethodConnection!

  # Get the full list of flat rate fulfillment method restrictions.
  getFlatRateFulfillmentRestrictions(
    # Shop to get restrictions for
    shopId: ID!

    # Return only results that come after this cursor. Use this with `first` to specify the number of results to return.
    after: ConnectionCursor

    # Return only results that come before this cursor. Use this with `last` to specify the number of results to return.
    before: ConnectionCursor

    # Return at most this many results. This parameter may be used with either `after` or `offset` parameters.
    first: ConnectionLimitInt

    # Return at most this many results. This parameter may be used with the `before` parameter.
    last: ConnectionLimitInt

    # Return only results that come after the Nth result. This parameter may be used with the `first` parameter.
    offset: Int

    # Return results sorted in this order
    sortOrder: SortOrder = desc

    # By default, restrictions are sorted by when they were created, newest first. Set this to sort by one of the other allowed fields
    sortBy: FlatRateFulfillmentRestrictionSortByField = createdAt
  ): FlatRateFulfillmentRestrictionConnection!

  # Get a single flat rate fulfillment method restriction.
  getFlatRateFulfillmentRestriction(
    # The restriction ID
    restrictionId: ID!

    # Shop that owns the restriction
    shopId: ID!
  ): FlatRateFulfillmentRestriction

  # List all tax codes supported by the current active tax service for the shop
  taxCodes(
    # The shop to use for getting the list of active tax services
    shopId: ID!
  ): [TaxCode]!

  # Get a full list of all tax services for the shop
  taxServices(
    # The shop to use for getting the list of all tax services
    shopId: ID!
  ): [TaxService]!

  # Gets tax rates
  taxRates(
    # Provide a shp ID from which you want to get tax rates
    shopId: ID!

    # Return only results that come after this cursor. Use this with `first` to specify the number of results to return.
    after: ConnectionCursor

    # Return only results that come before this cursor. Use this with `last` to specify the number of results to return.
    before: ConnectionCursor

    # Return at most this many results. This parameter may be used with either `after` or `offset` parameters.
    first: ConnectionLimitInt

    # Return at most this many results. This parameter may be used with the `before` parameter.
    last: ConnectionLimitInt

    # Return only results that come after the Nth result. This parameter may be used with the `first` parameter.
    offset: Int
  ): TaxRateConnection

  # Returns a navigation tree by its ID in the specified language
  navigationTreeById(
    # The ID of the navigation tee
    id: ID!

    # Navigation language
    language: String!

    # The ID of the shop to load navigation tree for
    shopId: ID!

    # Set to true if you want to include secondary navigation items along with the primary items
    shouldIncludeSecondary: Boolean = false
  ): NavigationTree

  # Returns the navigation items for a shop
  navigationItemsByShopId(
    # The ID of the shop to load navigation items for
    shopId: ID!

    # Return only results that come after this cursor. Use this with `first` to specify the number of results to return.
    after: ConnectionCursor

    # Return only results that come before this cursor. Use this with `last` to specify the number of results to return.
    before: ConnectionCursor

    # Return at most this many results. This parameter may be used with either `after` or `offset` parameters.
    first: ConnectionLimitInt

    # Return at most this many results. This parameter may be used with the `before` parameter.
    last: ConnectionLimitInt

    # Return only results that come after the Nth result. This parameter may be used with the `first` parameter.
    offset: Int

    # Return results sorted in this order
    sortOrder: SortOrder = desc

    # By default, items are sorted by when they were created, newest first. Set this to sort by one of the other allowed fields
    sortBy: NavigationItemSortByField = createdAt
  ): NavigationItemConnection

  # Returns Sitemap object for a shop based on the handle param
  sitemap(
    # The sitemap handle
    handle: String!

    # Shop URL
    shopUrl: String!
  ): Sitemap
  twoFactorSecret: TwoFactorSecretKey
  getUser: User
}

# Represents a Reaction shop
type Shop implements Node {
  # The shop ID
  _id: ID!

  # An the shop's default address
  addressBook: [Address]

  # Whether to allow user to checkout without creating an account
  allowGuestCheckout: Boolean

  # The base unit of length
  baseUOL: String

  # The base unit of Measure
  baseUOM: String

  # URLs for various shop assets in various sizes
  brandAssets: ShopBrandAssets

  # The default shop currency
  currency: Currency!

  # Default parcel size for this shop
  defaultParcelSize: ShopParcelSize

  # Shop description
  description: String

  # The shop's default email record
  emails: [EmailRecord]

  # Shop's keywords
  keywords: String

  # Shop default language
  language: String!

  # Shop name
  name: String!

  # Returns URLs for shop logos
  shopLogoUrls: ShopLogoUrls

  # Shop's type
  shopType: String

  # Shop's slug
  slug: String

  # Returns URLs for various storefront routes
  storefrontUrls: StorefrontUrls

  # Shop default timezone
  timezone: String

  # The shop's units of length
  unitsOfLength: [UnitOfLength]

  # The shop's units of measure
  unitsOfMeasure: [UnitOfMeasure]

  # Returns a list of groups for this shop, as a Relay-compatible connection.
  groups(
    # Return only results that come after this cursor. Use this with `first` to specify the number of results to return.
    after: ConnectionCursor

    # Return only results that come before this cursor. Use this with `last` to specify the number of results to return.
    before: ConnectionCursor

    # Return at most this many results. This parameter may be used with either `after` or `offset` parameters.
    first: ConnectionLimitInt

    # Return at most this many results. This parameter may be used with the `before` parameter.
    last: ConnectionLimitInt

    # Return only results that come after the Nth result. This parameter may be used with the `first` parameter.
    offset: Int

    # Return results sorted in this order
    sortOrder: SortOrder = asc

    # By default, groups are sorted by when they were created, oldest first. Set this to sort by one of the other allowed fields
    sortBy: GroupSortByField = createdAt
  ): GroupConnection

  # Returns a list of roles for this shop, as a Relay-compatible connection.
  roles(
    # Return only results that come after this cursor. Use this with `first` to specify the number of results to return.
    after: ConnectionCursor

    # Return only results that come before this cursor. Use this with `last` to specify the number of results to return.
    before: ConnectionCursor

    # Return at most this many results. This parameter may be used with either `after` or `offset` parameters.
    first: ConnectionLimitInt

    # Return at most this many results. This parameter may be used with the `before` parameter.
    last: ConnectionLimitInt

    # Return only results that come after the Nth result. This parameter may be used with the `first` parameter.
    offset: Int

    # Return results sorted in this order
    sortOrder: SortOrder = asc

    # By default, roles are sorted alphabetically by name. Set this to sort by one of the other allowed fields
    sortBy: RoleSortByField = name
  ): RoleConnection

  # Returns a paged list of tags for this shop
  tags(
    # If set, the query will return only top-level tags or only non-top-level tags. By default, both types of tags are returned.
    isTopLevel: Boolean

    # Set to true if you want soft deleted tags to be included in the response
    shouldIncludeDeleted: Boolean = false

    # Return only results that come after this cursor. Use this with `first` to specify the number of results to return.
    after: ConnectionCursor

    # Return only results that come before this cursor. Use this with `last` to specify the number of results to return.
    before: ConnectionCursor

    # Return at most this many results. This parameter may be used with either `after` or `offset` parameters.
    first: ConnectionLimitInt

    # Return at most this many results. This parameter may be used with the `before` parameter.
    last: ConnectionLimitInt

    # Return only results that come after the Nth result. This parameter may be used with the `first` parameter.
    offset: Int

    # Return results sorted in this order
    sortOrder: SortOrder = asc

    # By default, tags are sorted by position. Set this to sort by one of the other allowed fields
    sortBy: TagSortByField = position
  ): TagConnection

  # The default navigation tree for this shop
  defaultNavigationTree(
    # Navigation tree language
    language: String!

    # Whether to include secondary navigation items
    shouldIncludeSecondary: Boolean = false
  ): NavigationTree

  # The ID of the shop's default navigation tree
  defaultNavigationTreeId: String
}

# Objects implementing the Node interface will always have an _id field that is globally unique.
interface Node {
  # The ID of the object
  _id: ID!
}

# Represents a physical or mailing address somewhere on Earth
type Address {
  # The address ID
  _id: ID

  # The street address / first line
  address1: String!

  # Optional second line
  address2: String

  # City
  city: String!

  # Optional company name, if it's a business address
  company: String

  # Country
  country: String!

  # The first name of a person at this address
  # This is an optional field to support legacy and third party platforms
  # We use fullName internally, and use first and last name fields to combine into a full name if needed
  firstName: String

  # The full name of a person at this address
  fullName: String!

  # Is this the default address for billing purposes?
  isBillingDefault: Boolean

  # Is this a commercial address?
  isCommercial: Boolean!

  # Is this the default address to use when selecting a shipping address at checkout?
  isShippingDefault: Boolean

  # The last name of a person at this address
  # This is an optional field to support legacy and third party platforms
  # We use fullName internally, and use first and last name fields to combine into a full name if needed
  lastName: String

  # Arbitrary additional metadata about this address
  metafields: [Metafield]

  # A phone number for someone at this address
  phone: String!

  # Postal code
  postal: String!

  # Region. For example, a U.S. state
  region: String!
}

# User defined attributes
type Metafield {
  # Field description
  description: String

  # Field key
  key: String

  # Field namespace
  namespace: String

  # Field scope
  scope: String

  # Field value
  value: String

  # Field value type
  valueType: String
}

# URLs for various shop assets in various sizes
type ShopBrandAssets {
  # URLs for the navigation bar brand logo image
  navbarBrandImage: ImageSizes

  # Internal navigation bar brand logo image ID
  navbarBrandImageId: String
}

# A list of URLs for various sizes of an image
type ImageSizes {
  # Use this URL to get a large resolution file for this image
  large: String

  # Use this URL to get a medium resolution file for this image
  medium: String

  # Use this URL to get this image with its original resolution as uploaded. This may not be
  # the true original size if there is a hard cap on how big image files can be.
  original: String

  # Use this URL to get a small resolution file for this image
  small: String

  # Use this URL to get a thumbnail resolution file for this image
  thumbnail: String
}

# Represents one type of currency
type Currency implements Node {
  # ID
  _id: ID!

  # Currency code
  code: String!

  # Decimal symbol
  decimal: String

  # Format string
  format: String!

  # Exchange rate from shop default currency, if known
  rate: Float

  # The decimal scale used by this currency
  scale: Int

  # Currency symbol
  symbol: String!

  # Thousands separator symbol
  thousand: String
}

# Parcel size
type ShopParcelSize {
  # Parcel height
  height: Float

  # Parcel length
  length: Float

  # Parcel weight
  weight: Float

  # Parcel width
  width: Float
}

# A confirmable email record
type EmailRecord {
  # The actual email address
  address: String

  # The services provided by this address
  provides: String

  # Has this address been verified?
  verified: Boolean
}

# Shop logo URLs
type ShopLogoUrls {
  # The primary logo URL for this shop. Setting this overrides any uploaded logo.
  primaryShopLogoUrl: String
}

# Storefront route URLs
type StorefrontUrls {
  # Storefront Account Profile URL (can include `:accountId` in string)
  storefrontAccountProfileUrl: String

  # Storefront Home URL
  storefrontHomeUrl: String

  # Storefront login URL
  storefrontLoginUrl: String

  # Storefront single order URL (can include `:orderReferenceId` and `:orderToken` in string)
  storefrontOrderUrl: String

  # Storefront orders URL (can include `:accountId` in string)
  storefrontOrdersUrl: String
}

# Units of length
type UnitOfLength {
  # Whether this unit of length is the default
  default: Boolean

  # The name of the unit of length
  label: String

  # Unit of length
  uol: String
}

# Units of measure
type UnitOfMeasure {
  # Whether this unit of measure is the default
  default: Boolean

  # The name of the unit of measure
  label: String

  # Unit of measure
  uom: String
}

#
# An opaque string that identifies a particular result within a connection,
# allowing you to request a subset of results before or after that result.
#
scalar ConnectionCursor

#
# An integer between 1 and 50, inclusive. Values less than 1 become 1 and
# values greater than 50 become 50.
#
scalar ConnectionLimitInt

# The order in which the connection results should be sorted, based on the sortBy field.
enum SortOrder {
  # ascending
  asc

  # descending
  desc
}

# The fields by which you are allowed to sort any query that returns an `GroupConnection`
enum GroupSortByField {
  # Group ID
  _id

  # Date and time at which this group was created
  createdAt

  # Group name
  name

  # Date and time at which this group was last updated
  updatedAt
}

# Wraps a list of `Groups`, providing pagination cursors and information.
#
# For information about what Relay-compatible connections are and how to use them, see the following articles:
# - [Relay Connection Documentation](https://facebook.github.io/relay/docs/en/graphql-server-specification.html#connections)
# - [Relay Connection Specification](https://facebook.github.io/relay/graphql/connections.htm)
# - [Using Relay-style Connections With Apollo Client](https://www.apollographql.com/docs/react/recipes/pagination.html)
type GroupConnection {
  # The list of nodes that match the query, wrapped in an edge to provide a cursor string for each
  edges: [GroupEdge]

  # You can request the `nodes` directly to avoid the extra wrapping that `NodeEdge` has,
  # if you know you will not need to paginate the results.
  nodes: [Group]

  # Information to help a client request the next or previous page
  pageInfo: PageInfo!

  # The total number of nodes that match your query
  totalCount: Int!
}

# A connection edge in which each node is a `Group` object
type GroupEdge implements NodeEdge {
  # The cursor that represents this node in the paginated results
  cursor: ConnectionCursor!

  # The group
  node: Group
}

# Objects implementing the NodeEdge interface will always have a node and a cursor
# that represents that node for purposes of requesting paginated results.
interface NodeEdge {
  # The cursor that represents this node in the paginated results
  cursor: ConnectionCursor!

  # The node itself
  node: Node
}

# Represents an account group
type Group implements Node {
  # The group ID
  _id: ID!

  # The date and time at which this group was created
  createdAt: DateTime!

  # The account that created this group
  createdBy: Account

  # A free text description of this group
  description: String

  # A unique name for the group
  name: String!

  # The shop to which this group belongs
  shop: Shop

  # A unique URL-safe string representing this group
  slug: String!

  # The date and time at which this group was last updated
  updatedAt: DateTime!

  # A list of the account permissions implied by membership in this group
  permissions: [String]
}

# A date-time string at UTC, such as 2007-12-03T10:15:30Z, compliant with the `date-time` format outlined in section 5.6 of the RFC 3339 profile of the ISO 8601 standard for representation of dates and times using the Gregorian calendar.
scalar DateTime

# Represents a single user account
type Account implements Node {
  # The account ID
  _id: ID!

  # A list of physical or mailing addresses associated with this account
  addressBook(
    # Return only results that come after this cursor. Use this with `first` to specify the number of results to return.
    after: ConnectionCursor

    # Return only results that come before this cursor. Use this with `last` to specify the number of results to return.
    before: ConnectionCursor

    # Return at most this many results. This parameter may be used with either `after` or `offset` parameters.
    first: ConnectionLimitInt

    # Return at most this many results. This parameter may be used with the `before` parameter.
    last: ConnectionLimitInt

    # Return only results that come after the Nth result. This parameter may be used with the `first` parameter.
    offset: Int
  ): AddressConnection

  # A list of shops this user can administer with the admin UI
  adminUIShops: [Shop]

  # Bio to display on profile
  bio: String

  # The date and time at which this account was created
  createdAt: DateTime!

  # The preferred currency used by this account
  currency: Currency

  # A list of email records associated with this account
  emailRecords: [EmailRecord]

  # The first name of the person this account represents, if known
  firstName: String

  # The preferred language used by this account
  language: String

  # The last name of the person this account represents, if known
  lastName: String

  # Arbitrary additional metadata about this account
  metafields: [Metafield]

  # The full name of the person this account represents, if known
  name: String

  # Some note about this account
  note: String

  # URL of picture to display on profile
  picture: String

  # An object storing plugin-specific preferences for this account
  preferences: JSONObject

  # The primary email address for the account. This matches the address in `emailRecords` where `provides` is `default`.
  primaryEmailAddress: Email!

  # The date and time at which this account was last updated
  updatedAt: DateTime

  # The Identity user ID with which this account is associated
  userId: String!

  # Username
  username: String

  # A paged list of the account groups in which this account is listed
  groups(
    # Return only results that come after this cursor. Use this with `first` to specify the number of results to return.
    after: ConnectionCursor

    # Return only results that come before this cursor. Use this with `last` to specify the number of results to return.
    before: ConnectionCursor

    # Return at most this many results. This parameter may be used with either `after` or `offset` parameters.
    first: ConnectionLimitInt

    # Return at most this many results. This parameter may be used with the `before` parameter.
    last: ConnectionLimitInt

    # Return only results that come after the Nth result. This parameter may be used with the `first` parameter.
    offset: Int

    # Return results sorted in this order
    sortOrder: SortOrder = asc

    # By default, groups are sorted by when they were created, oldest first. Set this to sort by one of the other allowed fields
    sortBy: GroupSortByField = createdAt
  ): GroupConnection
}

# Wraps a list of `Addresses`, providing pagination cursors and information.
#
# For information about what Relay-compatible connections are and how to use them, see the following articles:
# - [Relay Connection Documentation](https://facebook.github.io/relay/docs/en/graphql-server-specification.html#connections)
# - [Relay Connection Specification](https://facebook.github.io/relay/graphql/connections.htm)
# - [Using Relay-style Connections With Apollo Client](https://www.apollographql.com/docs/react/recipes/pagination.html)
type AddressConnection {
  # The list of nodes that match the query, wrapped in an edge to provide a cursor string for each
  edges: [AddressEdge]

  # You can request the `nodes` directly to avoid the extra wrapping that `NodeEdge` has,
  # if you know you will not need to paginate the results.
  nodes: [Address]

  # Information to help a client request the next or previous page
  pageInfo: PageInfo!

  # The total number of nodes that match your query
  totalCount: Int!
}

# A connection edge in which each node is an `Address` object
type AddressEdge {
  # The cursor that represents this node in the paginated results
  cursor: ConnectionCursor!

  # The address
  node: Address
}

# Pagination information. When requesting pages of results, you can use endCursor or startCursor
# as your before or after parameters for the query you are paging.
type PageInfo {
  # When paginating forwards, the cursor to continue.
  endCursor: ConnectionCursor

  # When paginating forwards, are there more items?
  hasNextPage: Boolean!

  # When paginating backwards, are there more items?
  hasPreviousPage: Boolean!

  # When paginating backwards, the cursor to continue.
  startCursor: ConnectionCursor
}

# An object with any fields
scalar JSONObject

# A string email address
scalar Email

# The fields by which you are allowed to sort any query that returns an `RoleConnection`
enum RoleSortByField {
  # Role ID
  _id

  # Role name
  name
}

# Wraps a list of `Roles`, providing pagination cursors and information.
#
# For information about what Relay-compatible connections are and how to use them, see the following articles:
# - [Relay Connection Documentation](https://facebook.github.io/relay/docs/en/graphql-server-specification.html#connections)
# - [Relay Connection Specification](https://facebook.github.io/relay/graphql/connections.htm)
# - [Using Relay-style Connections With Apollo Client](https://www.apollographql.com/docs/react/recipes/pagination.html)
type RoleConnection {
  # The list of nodes that match the query, wrapped in an edge to provide a cursor string for each
  edges: [RoleEdge]

  # You can request the `nodes` directly to avoid the extra wrapping that `NodeEdge` has,
  # if you know you will not need to paginate the results.
  nodes: [Role]

  # Information to help a client request the next or previous page
  pageInfo: PageInfo!

  # The total number of nodes that match your query
  totalCount: Int!
}

# A connection edge in which each node is a `Role` object
type RoleEdge implements NodeEdge {
  # The cursor that represents this node in the paginated results
  cursor: ConnectionCursor!

  # The role
  node: Role
}

# Represents a named role
type Role implements Node {
  # The role ID
  _id: ID!

  # A unique name for the role
  name: String!
}

# The fields by which you are allowed to sort any query that returns a `TagConnection`
enum TagSortByField {
  # Tag ID
  _id

  # Date and time the tag was created
  createdAt

  # Tag name
  name

  # Tag position
  position

  # Date and time the tag was last updated
  updatedAt
}

# Wraps a list of `Tags`, providing pagination cursors and information.
#
# For information about what Relay-compatible connections are and how to use them, see the following articles:
# - [Relay Connection Documentation](https://facebook.github.io/relay/docs/en/graphql-server-specification.html#connections)
# - [Relay Connection Specification](https://facebook.github.io/relay/graphql/connections.htm)
# - [Using Relay-style Connections With Apollo Client](https://www.apollographql.com/docs/react/recipes/pagination.html)
type TagConnection {
  # The list of nodes that match the query, wrapped in an edge to provide a cursor string for each
  edges: [TagEdge]

  # You can request the `nodes` directly to avoid the extra wrapping that `NodeEdge` has,
  # if you know you will not need to paginate the results.
  nodes: [Tag]

  # Information to help a client request the next or previous page
  pageInfo: PageInfo!

  # The total number of nodes that match your query
  totalCount: Int!
}

# A connection edge in which each node is a `Tag` object
type TagEdge implements NodeEdge {
  # The cursor that represents this node in the paginated results
  cursor: ConnectionCursor!

  # The tag
  node: Tag
}

# Represents a single tag
type Tag implements Node & Deletable {
  # The tag ID
  _id: ID!

  # The date and time at which this tag was created
  createdAt: DateTime!

  # A string of the title to be displayed on a Tag Listing Page
  displayTitle: String

  # A list of the IDs of top products in this tag
  featuredProductIds: [ID]

  # A string containing the hero image url for a Tag Listing Page
  heroMediaUrl: String

  # If `true`, this object should be considered deleted. Soft deleted objects are not
  # returned in query results unless you explicitly ask for them.
  isDeleted: Boolean!

  # If `true`, this tag should be shown at the top level of the tag hierarchy
  isTopLevel: Boolean!

  # If `true`, this tag's Tag Listing Page should be visible to the public
  isVisible: Boolean!

  # Arbitrary additional metadata about this tag
  metafields: [Metafield]

  # The display name for the tag. This is unique within a given shop.
  name: String!

  # The tag's position relative to other tags at the same level of the tag hierarchy
  position: Int

  # The shop to which this tag belongs
  shop: Shop!

  # A unique URL-safe string representing this tag for links
  slug: String

  # A list of the IDs of tags that have this tag as their parent in the tag hierarchy, in the user-defined order
  subTagIds: [ID]!

  # The date and time at which this tag was last updated
  updatedAt: DateTime!

  # A paged list of tags that have this tag as their parent in the tag hierarchy. Currently only three levels are supported.
  subTags(
    # Return only results that come after this cursor. Use this with `first` to specify the number of results to return.
    after: ConnectionCursor

    # Return only results that come before this cursor. Use this with `last` to specify the number of results to return.
    before: ConnectionCursor

    # Return at most this many results. This parameter may be used with either `after` or `offset` parameters.
    first: ConnectionLimitInt

    # Return at most this many results. This parameter may be used with the `before` parameter.
    last: ConnectionLimitInt

    # Return only results that come after the Nth result. This parameter may be used with the `first` parameter.
    offset: Int

    # Return results sorted in this order
    sortOrder: SortOrder = asc

    # By default, tags are sorted by position. Set this to sort by one of the other allowed fields
    sortBy: TagSortByField = position
  ): TagConnection
}

# Objects implementing the Deletable support soft deletion
interface Deletable {
  # If true, this object should be considered deleted. Soft deleted objects are not
  # returned in query results unless you explicitly ask for them.
  isDeleted: Boolean!
}

# Represents a navigation tree containing multiple levels of navigation items
type NavigationTree implements Node {
  # The navigation tree ID
  _id: ID!

  # The draft navigation items that make up this tree
  draftItems: [NavigationTreeItem]

  # Whether the navigation item has unpublished changes
  hasUnpublishedChanges: Boolean

  # The published navigation items that make up this tree
  items: [NavigationTreeItem]

  # The name of the tree, for operator display purposes. Assumed to be in the primary shop's language
  name: String!

  # The ID of the shop this navigation tree belongs to
  shopId: ID!
}

# Represents a navigation item and its children in a tree
type NavigationTreeItem {
  # Whether the navigation item should display its children
  expanded: Boolean

  # Whether the navigation item should be hidden from customers
  isPrivate: Boolean

  # Whether the navigaton item is a secondary navigation item
  isSecondary: Boolean

  # Whether the navigation ttem should shown in query results for customers and admins
  isVisible: Boolean

  # The child navigation items
  items: [NavigationTreeItem]

  # The navigation item
  navigationItem: NavigationItem!
}

# Represents a single navigation item
type NavigationItem implements Node {
  # The navigation item ID
  _id: ID!

  # The date and time at which this navigation item was created
  createdAt: DateTime!

  # The published data for this navigation item
  data: NavigationItemData

  # The draft/unpublished data for this navigation item
  draftData: NavigationItemData

  # Whether the navigation item has unpublished changes
  hasUnpublishedChanges: Boolean

  # An object storing additional metadata about the navigation item (such as its related tag)
  metadata: JSONObject

  # The ID of the shop the navigation item belongs to
  shopId: ID!
}

# Represents the data for a navigation item
type NavigationItemData {
  # CSS class names to add to the menu item for display
  classNames: String

  # The content for the navigation item, in one or more languages
  content: [NavigationItemContent]

  # The translated content for a navigation item
  contentForLanguage: String

  # Whether the provided URL is relative or external
  isUrlRelative: Boolean

  # Whether the navigation item should trigger a new tab/window to open when clicked
  shouldOpenInNewWindow: Boolean

  # The URL for the navigation item to link to
  url: String
}

# Represents the translated content for a navigation item
type NavigationItemContent {
  # The language of the piece of navigation content
  language: String!

  # The translated value, in plain text or markdown
  value: String
}

# Wraps a list of `Shops`, providing pagination cursors and information.
#
# For information about what Relay-compatible connections are and how to use them, see the following articles:
# - [Relay Connection Documentation](https://facebook.github.io/relay/docs/en/graphql-server-specification.html#connections)
# - [Relay Connection Specification](https://facebook.github.io/relay/graphql/connections.htm)
# - [Using Relay-style Connections With Apollo Client](https://www.apollographql.com/docs/react/recipes/pagination.html)
type ShopConnection {
  # The list of nodes that match the query, wrapped in an edge to provide a cursor string for each
  edges: [ShopEdge]

  # You can request the `nodes` directly to avoid the extra wrapping that `NodeEdge` has,
  # if you know you will not need to paginate the results.
  nodes: [Shop]

  # Information to help a client request the next or previous page
  pageInfo: PageInfo!

  # The total number of nodes that match your query
  totalCount: Int!
}

# A connection edge in which each node is an `Shop` object
type ShopEdge implements NodeEdge {
  # The cursor that represents this node in the paginated results
  cursor: ConnectionCursor!

  # The Shop
  node: Shop
}

# App settings that are not shop specific. Plugins extend the GlobalSettings type to support
# whatever settings they need.
type GlobalSettings {
  # A fake setting necessary until some plugin extends this with a real setting
  doNotUse: String
}

# App settings for a specific shop. Plugins extend the ShopSettings type to support
# whatever settings they need.
type ShopSettings {
  # A fake setting necessary until some plugin extends this with a real setting
  doNotUse: String

  # If there is no known inventory for a product configuration, this setting determines
  # whether that product configuration can be sold and should appear to be available.
  canSellVariantWithoutInventory: Boolean!

  # If `false` no defined shipping rates will be used when fulfillment
  # quotes are requested for a cart or order. A quick way to disable the entire
  # `reaction-shipping-rates` plugin temporarily.
  isShippingRatesFulfillmentEnabled: Boolean

  # The default value to use for `taxCode` property of a product
  defaultTaxCode: String

  # The name of the tax service to fall back to if the primary tax service is down.
  # This will match the `name` field of one of the services returned by the `taxServices`
  # query.
  fallbackTaxServiceName: String

  # The name of the tax service to use for calculating taxes on carts and orders.
  # This will match the `name` field of one of the services returned by the `taxServices`
  # query.
  primaryTaxServiceName: String

  # Whether a navigation item added to the navigation tree should be visible only to
  # admins by default.
  shouldNavigationTreeItemsBeAdminOnly: Boolean!

  # Whether a navigation item added to the navigation tree should be
  # public API/Storefront visible by default.
  shouldNavigationTreeItemsBePubliclyVisible: Boolean!

  # Whether a navigation item added to the navigation tree should be a secondary
  # navigation item by default.
  shouldNavigationTreeItemsBeSecondaryNavOnly: Boolean!

  # This setting controls how often the sitemaps for the shop will be rebuilt
  sitemapRefreshPeriod: String!
}

# Wraps a list of `EmailJob`s, providing pagination cursors and information.
#
# For information about what Relay-compatible connections are and how to use them, see the following articles:
# - [Relay Connection Documentation](https://facebook.github.io/relay/docs/en/graphql-server-specification.html#connections)
# - [Relay Connection Specification](https://facebook.github.io/relay/graphql/connections.htm)
# - [Using Relay-style Connections With Apollo Client](https://www.apollographql.com/docs/react/recipes/pagination.html)
type EmailJobConnection {
  # The list of nodes that match the query, wrapped in an edge to provide a cursor string for each
  edges: [EmailJobEdge]

  # You can request the `nodes` directly to avoid the extra wrapping that `NodeEdge` has,
  # if you know you will not need to paginate the results.
  nodes: [EmailJob]

  # Information to help a client request the next or previous page
  pageInfo: PageInfo!

  # The total number of nodes that match your query
  totalCount: Int!
}

# A connection edge in which each node is an `EmailJob` object
type EmailJobEdge {
  # The cursor that represents this node in the paginated results
  cursor: ConnectionCursor!

  # The product
  node: EmailJob
}

# An e-mail job
type EmailJob {
  # The ID of the e-mail job
  _id: ID!

  # The date and time of the last update to the e-mail job
  updated: DateTime!

  # The status of the e-mail job
  status: String!

  # The data of the e-mail
  data: EmailJobData!
}

# The data of the e-mail
type EmailJobData {
  # The address the e-mail was/is being/will be sent to
  to: String!

  # The subject of the e-mail
  subject: String!
}

# The details of an `Address` to be created or updated
input AddressInput {
  # The street address / first line
  address1: String!

  # Optional second line
  address2: String

  # Optionally, a name for this address (e.g. 'Home') to easily identify it in the future
  addressName: String

  # City
  city: String!

  # Optional company name, if it's a business address
  company: String

  # Country
  country: String!

  # The first name of a person at this address
  # This is an optional field to support legacy and third party platforms
  # We use fullName internally, and use first and last name fields to combine into a full name if needed
  firstName: String

  # The full name of a person at this address
  fullName: String!

  # Is this the default address for billing purposes?
  isBillingDefault: Boolean

  # Is this a commercial address?
  isCommercial: Boolean

  # Is this the default address to use when selecting a shipping address at checkout?
  isShippingDefault: Boolean

  # The last name of a person at this address
  # This is an optional field to support legacy and third party platforms
  # We use fullName internally, and use first and last name fields to combine into a full name if needed
  lastName: String

  # Arbitrary additional metadata about this address
  metafields: [MetafieldInput]

  # A phone number for someone at this address
  phone: String!

  # Postal code
  postal: String!

  # Region. For example, a U.S. state
  region: String!
}

# User defined attributes. You can include only `key` and use these like tags, or also include a `value`.
input MetafieldInput {
  # Field description
  description: String

  # Field key
  key: String!

  # Field namespace
  namespace: String

  # Field scope
  scope: String

  # Field value
  value: String

  # Field value type
  valueType: String
}

# The response from `Query.addressValidation`
type AddressValidationResults {
  # A list of suggested addresses. If the address is valid as is OR the address input is invalid OR
  # the shop is not configured to validate addresses, then this will be empty.
  suggestedAddresses: [SuggestedAddress]!

  # This may have information about the ways in which the provided address input is incomplete or invalid.
  # Show these errors in the address review user interface.
  validationErrors: [AddressValidationError]!
}

# An address suggestion returned from an address validation service
type SuggestedAddress {
  # The street address / first line
  address1: String!

  # Optional second line
  address2: String

  # City
  city: String!

  # Country
  country: String!

  # Postal code
  postal: String!

  # Region. For example, a U.S. state
  region: String!
}

# Details about an error that was the result of validating an address that is invalid
type AddressValidationError {
  # A longer, detailed error message suitable for showing in the user interface
  details: String

  # An identifier of the source of this error. These are not currently standardized. As long as your client understands it, any string is fine.
  source: String

  # A short error message suitable for showing in the user interface
  summary: String!

  # The error type. These are not currently standardized. As long as your client understands it, any string is fine.
  type: String!
}

# A single registered address validation service
type AddressValidationService {
  # Human-readable name to show operators
  displayName: String!

  # Unique name to serve as a key identifying this service
  name: String!

  # An optional list of all country codes that this address service supports. Null means all countries.
  supportedCountryCodes: [String]
}

# The fields by which you are allowed to sort any query that returns an `AddressValidationRuleConnection`
enum AddressValidationRuleSortByField {
  # AddressValidationRule ID
  _id

  # Date and time at which the rule was created
  createdAt

  # Service name
  serviceName

  # Date and time at which the rule was last updated
  updatedAt
}

# Wraps a list of `AddressValidationRules`, providing pagination cursors and information.
#
# For information about what Relay-compatible connections are and how to use them, see the following articles:
# - [Relay Connection Documentation](https://facebook.github.io/relay/docs/en/graphql-server-specification.html#connections)
# - [Relay Connection Specification](https://facebook.github.io/relay/graphql/connections.htm)
# - [Using Relay-style Connections With Apollo Client](https://www.apollographql.com/docs/react/recipes/pagination.html)
type AddressValidationRuleConnection {
  # The list of nodes that match the query, wrapped in an edge to provide a cursor string for each
  edges: [AddressValidationRuleEdge]

  # You can request the `nodes` directly to avoid the extra wrapping that `NodeEdge` has,
  # if you know you will not need to paginate the results.
  nodes: [AddressValidationRule]

  # Information to help a client request the next or previous page
  pageInfo: PageInfo!

  # The total number of nodes that match your query
  totalCount: Int!
}

# A connection edge in which each node is a `AddressValidationRule` object
type AddressValidationRuleEdge implements NodeEdge {
  # The cursor that represents this node in the paginated results
  cursor: ConnectionCursor!

  # The address validation rule
  node: AddressValidationRule
}

# An address validation rule specifies which validation services should run for
# which countries in each shop.
type AddressValidationRule implements Node {
  # The rule ID
  _id: ID!

  # Country codes for which this service is enabled
  countryCodes: [String]

  # The date and time at which this rule was created
  createdAt: DateTime!

  # The name of one of the installed validation services. Use `addressValidationServices`
  # query to get a list with more details about all installed services.
  serviceName: String!

  # ID of the shop to which this rule applies
  shopId: ID!

  # The date and time at which this rule was last updated
  updatedAt: DateTime!
}

# Represents Reaction System Infomation
type SystemInformation {
  # Core api version
  apiVersion: String!

  # Mongo version
  mongoVersion: DatabaseInformation!

  # Plugins installed with name, version information
  plugins: [Plugin]
}

# Represents Mongo Database information
type DatabaseInformation {
  # Version of database
  version: String!
}

# Represents Reaction Plugin
type Plugin {
  # Name of plugin
  name: String!

  # Version of plugin
  version: String
}

# Wraps a list of Templates, providing pagination cursors and information.
#
# For information about what Relay-compatible connections are and how to use them, see the following articles:
# - [Relay Connection Documentation](https://facebook.github.io/relay/docs/en/graphql-server-specification.html#connections)
# - [Relay Connection Specification](https://facebook.github.io/relay/graphql/connections.htm)
# - [Using Relay-style Connections With Apollo Client](https://www.apollographql.com/docs/react/recipes/pagination.html)
type TemplateConnection {
  # The list of nodes that match the query, wrapped in an edge to provide a cursor string for each
  edges: [TemplateEdge]

  # You can request the `nodes` directly to avoid the extra wrapping that `NodeEdge` has,
  # if you know you will not need to paginate the results.
  nodes: [Template]

  # Information to help a client request the next or previous page
  pageInfo: PageInfo!

  # The total number of nodes that match your query
  totalCount: Int!
}

# A connection edge in which each node is a `Template` object
type TemplateEdge {
  # The cursor that represents this node in the paginated results
  cursor: ConnectionCursor!

  # The email template
  node: Template
}

# Represents a Template
type Template implements Node {
  # The shop ID
  _id: ID!

  # Email template language
  language: String

  # Email template name
  name: String

  # The shop that owns the template
  shopId: ID!

  # Email template string
  subject: String

  # Email template body or html text
  template: String

  # Email template title
  title: String
}

# The fields by which you are allowed to sort any query that returns an `AccountConnection`
enum AccountSortByField {
  # Account ID
  _id

  # Date and time at which this account was created
  createdAt

  # Date and time at which this account was last updated
  updatedAt
}

# Wraps a list of `Accounts`, providing pagination cursors and information.
#
# For information about what Relay-compatible connections are and how to use them, see the following articles:
# - [Relay Connection Documentation](https://facebook.github.io/relay/docs/en/graphql-server-specification.html#connections)
# - [Relay Connection Specification](https://facebook.github.io/relay/graphql/connections.htm)
# - [Using Relay-style Connections With Apollo Client](https://www.apollographql.com/docs/react/recipes/pagination.html)
type AccountConnection {
  # The list of nodes that match the query, wrapped in an edge to provide a cursor string for each
  edges: [AccountEdge]

  # You can request the `nodes` directly to avoid the extra wrapping that `NodeEdge` has,
  # if you know you will not need to paginate the results.
  nodes: [Account]

  # Information to help a client request the next or previous page
  pageInfo: PageInfo!

  # The total number of nodes that match your query
  totalCount: Int!
}

# A connection edge in which each node is an `Account` object
type AccountEdge implements NodeEdge {
  # The cursor that represents this node in the paginated results
  cursor: ConnectionCursor!

  # The account
  node: Account
}

# Wraps a list of `Invitation`s, providing pagination cursors and information.
#
# For information about what Relay-compatible connections are and how to use them, see the following articles:
# - [Relay Connection Documentation](https://facebook.github.io/relay/docs/en/graphql-server-specification.html#connections)
# - [Relay Connection Specification](https://facebook.github.io/relay/graphql/connections.htm)
# - [Using Relay-style Connections With Apollo Client](https://www.apollographql.com/docs/react/recipes/pagination.html)
type InvitationConnection {
  # The list of nodes that match the query, wrapped in an edge to provide a cursor string for each
  edges: [InvitationEdge]

  # You can request the `nodes` directly to avoid the extra wrapping that `NodeEdge` has,
  # if you know you will not need to paginate the results.
  nodes: [Invitation]

  # Information to help a client request the next or previous page
  pageInfo: PageInfo!

  # The total number of nodes that match your query
  totalCount: Int!
}

# A connection edge in which each node is an `Invitation` object
type InvitationEdge implements NodeEdge {
  # The cursor that represents this node in the paginated results
  cursor: ConnectionCursor!

  # The account
  node: Invitation
}

# Represents a single staff member invitation
type Invitation implements Node {
  # The invitation ID
  _id: ID!

  # The e-mail address the invitation was sent to
  email: String!

  # The groups this person was invited to
  groups: [Group]!

  # The shop this person was invited to. Optional because we can also invite merchants to create their own shops.
  shop: Shop

  # The admin who invited this person
  invitedBy: Account
}

# A Reaction product
type Product {
  # Product ID
  _id: ID!

  # The date and time at which this product was created
  createdAt: DateTime!

  # Hash to compare with publishedProductHash, to see if this product has changed since it was last published
  currentProductHash: String

  # The full product description, which may have newline characters in it
  description: String

  # True if this product has been deleted. Typically, deleted products are not returned in queries.
  isDeleted: Boolean!

  # True if this product should be shown to shoppers. Typically, non-visible products are not returned in queries.
  isVisible: Boolean!

  # All media for a product
  media(
    # Determines whether variant media should be included in the product or not
    shouldIncludeVariantMedia: Boolean = true
  ): [ImageInfo]

  # The product description to use for page `description` meta element in HTML
  metaDescription: String

  # Arbitrary additional metadata about this product
  metafields: [Metafield]!

  # The country of origin
  originCountry: String

  # Subtitle
  pageTitle: String

  # An arbitrary product type value, such as from an external system
  productType: String

  # The date and time at which this product was last published. If `null`, it has never been published.
  publishedAt: DateTime

  # Hash to compare with currentProductHash, to see if this product has changed since it was last published
  publishedProductHash: String

  # The shop to which this product belongs
  shop: Shop!

  # Whether this product will be shown in the generated sitemap
  shouldAppearInSitemap: Boolean

  # A URL-safe and human-readable string that uniquely identifies this product
  slug: String

  # Holds metadata specific to a specific social network service
  socialMetadata: [SocialMetadata]

  # When a shopper purchases this product, what types of fulfillment can they choose from?
  supportedFulfillmentTypes: [FulfillmentType]!

  # The list of tag IDs that have been applied to this product
  tagIds: [ID]

  # The list of tags that have been applied to this product
  tags(
    # Return only results that come after this cursor. Use this with `first` to specify the number of results to return.
    after: ConnectionCursor

    # Return only results that come before this cursor. Use this with `last` to specify the number of results to return.
    before: ConnectionCursor

    # Return at most this many results. This parameter may be used with either `after` or `offset` parameters.
    first: ConnectionLimitInt

    # Return at most this many results. This parameter may be used with the `before` parameter.
    last: ConnectionLimitInt

    # Return only results that come after the Nth result. This parameter may be used with the `first` parameter.
    offset: Int

    # Return results sorted in this order
    sortOrder: SortOrder = asc

    # By default, tags are sorted by ID. Set this to sort by one of the other allowed fields
    sortBy: TagSortByField = _id
  ): TagConnection

  # Product title
  title: String

  # The date and time at which this product was last updated
  updatedAt: DateTime

  # A list of all variants for this product
  variants(
    # Include hidden variants
    shouldIncludeHidden: Boolean = true

    # Include archived variants
    shouldIncludeArchived: Boolean = false
  ): [ProductVariant]!

  # The product vendor or manufacturer, for display
  vendor: String

  # Price range
  price: ProductPriceRange @deprecated(reason: "Use `pricing`")

  # Pricing information
  pricing: ProductPricingInfo!
}

# Information about an image
type ImageInfo {
  # A list of URLs for various size files of this image
  URLs: ImageSizes

  # ID
  _id: ID

  # Sort by priority ascending when displaying more than one image for a product in a user interface.
  # This is an integer with 1 being the first / highest priority image.
  priority: Int

  # The related product ID
  productId: ID

  # The related variant ID, if linked with a particular variant
  variantId: ID
}

# Holds metadata specific to a specific social network service
type SocialMetadata {
  # Default share message to use when sharing this product on this social network
  message: String

  # Which social network is this metadata for
  service: SocialNetwork
}

# The list of currently supported social network identifiers
enum SocialNetwork {
  # Facebook
  facebook

  # Google+
  googleplus

  # Pinterest
  pinterest

  # Twitter
  twitter
}

# Allowed fulfillment types
enum FulfillmentType {
  # An order will be fulfilled digitally, such as by sending a download link
  digital

  # An order will be fulfilled by the customer picking it up
  pickup

  # An order will be fulfilled by the seller shipping it to the customer
  shipping
}

# A Reaction product variant or option
type ProductVariant {
  # Variant ID
  _id: ID!

  # The attribute label describes the category of variant, for example, `Color` or `Size`.
  # In most cases this will be the same for all variants at the same level.
  attributeLabel: String

  # The product variant barcode value, if it has one
  barcode: String

  # The date and time at which this variant was created
  createdAt: DateTime

  # The height of the product variant, if it has physical dimensions
  height: Float

  # The position of this variant among other variants at the same level of the product-variant-option hierarchy
  index: Int

  # True if this variant was deleted. Deleted variants are not published to the catalog.
  isDeleted: Boolean!

  # True if this variant is visible. Hidden variants are not published to the catalog.
  isVisible: Boolean!

  # The length of the product, if it has physical dimensions
  length: Float

  # All media for a variant
  media: [ImageInfo]

  # Arbitrary additional metadata about this product
  metafields: [Metafield]!

  # The minimum quantity that must be added to a cart
  minOrderQuantity: Int

  # A short title to use for product detail select lists
  optionTitle: String

  # Child variants, if any
  options(
    # Include hidden variants
    shouldIncludeHidden: Boolean = true

    # Include archived variants
    shouldIncludeArchived: Boolean = false
  ): [ProductVariant]!

  # The country of origin
  originCountry: String

  # The shop to which this product variant belongs
  shop: Shop!

  # SKU of variant
  sku: String

  # The full variant title for use on cart, checkout, and order summaries and on invoices.
  # This fully describes the configured variant. For example, if this is an option with
  # `optionTitle` "Large", its parent variant has `optionTitle` `Red`, and the product
  # `title` is "Fancy T-Shirt", then this `title` will be something like `Fancy T-Shirt - Red - Large`.
  title: String

  # The date and time at which this product was last updated
  updatedAt: DateTime

  # The weight of the product on Earth, if it has physical dimensions
  weight: Float

  # The width of the product, if it has physical dimensions
  width: Float

  # Compare at price of the variant
  compareAtPrice: Float @deprecated(reason: "Use `pricing`")

  # Price of the variant
  price: Float @deprecated(reason: "Use `pricing`")

  # Pricing information
  pricing: ProductPricingInfo!

  # Whether this variant is taxable
  isTaxable: Boolean

  # Tax code
  taxCode: String

  # Tax description
  taxDescription: String
}

# The product price or price range for a specific currency
type ProductPricingInfo {
  # A comparison price value, usually MSRP. If `price` is null, this will also be null. That is,
  # only purchasable variants will have a `compareAtPrice`.
  compareAtPrice: Money

  # The code for the currency these pricing details applies to
  currency: Currency!

  # Pricing converted to specified currency
  currencyExchangePricing(
    # Code for the currency in which you want to see pricing info
    currencyCode: String!
  ): CurrencyExchangeProductPricingInfo

  # UI should display this price. If a product has multiple potential prices depending on selected
  # variants and options, then this is a price range string such as "$3.95 - $6.99". It includes the currency
  # symbols.
  displayPrice: String!

  # The price of the most expensive possible variant+option combination
  maxPrice: Float!

  # The price of the least expensive possible variant+option combination
  minPrice: Float!

  # For variants with no options and for options, this will always be set to a price. For variants
  # with options and products, this will be `null`. There must be a price for a variant to be
  # added to a cart or purchased. Otherwise you would instead add one of its child options to a cart.
  price: Float
}

# Represents some amount of a single currency
type Money {
  # The numeric amount
  amount: Float!

  # The currency, for interpreting the `amount`
  currency: Currency!

  # The display amount, with any currency symbols and decimal places already added
  displayAmount: String!
}

# The product price or price range for a specific currency
type CurrencyExchangeProductPricingInfo {
  # A comparison price value, usually MSRP. If `price` is null, this will also be null. That is,
  # only purchasable variants will have a `compareAtPrice`.
  compareAtPrice: Money

  # The code for the currency these pricing details applies to
  currency: Currency!

  # UI should display this price. If a product has multiple potential prices depending on selected
  # variants and options, then this is a price range string such as "$3.95 - $6.99". It includes the currency
  # symbols.
  displayPrice: String!

  # The price of the most expensive possible variant+option combination
  maxPrice: Float!

  # The price of the least expensive possible variant+option combination
  minPrice: Float!

  # For variants with no options and for options, this will always be set to a price. For variants
  # with options and products, this will be `null`. There must be a price for a variant to be
  # added to a cart or purchased. Otherwise you would instead add one of its child options to a cart.
  price: Float
}

# Product price range
type ProductPriceRange {
  # Maximum price in range
  max: Float

  # Minimum price in range
  min: Float

  # Price range display
  range: String
}

# The fields by which you are allowed to sort any query that returns a `ProductConnection`
enum ProductSortByField {
  # Product ID
  _id

  # Date and time the product was created
  createdAt

  # Product title
  title

  # Date and time the product was last updated
  updatedAt
}

# Wraps a list of Products`s, providing pagination cursors and information.
#
# For information about what Relay-compatible connections are and how to use them, see the following articles:
# - [Relay Connection Documentation](https://facebook.github.io/relay/docs/en/graphql-server-specification.html#connections)
# - [Relay Connection Specification](https://facebook.github.io/relay/graphql/connections.htm)
# - [Using Relay-style Connections With Apollo Client](https://www.apollographql.com/docs/react/recipes/pagination.html)
type ProductConnection {
  # The list of nodes that match the query, wrapped in an edge to provide a cursor string for each
  edges: [ProductEdge]

  # You can request the `nodes` directly to avoid the extra wrapping that `NodeEdge` has,
  # if you know you will not need to paginate the results.
  nodes: [Product]

  # Information to help a client request the next or previous page
  pageInfo: PageInfo!

  # The total number of nodes that match your query
  totalCount: Int!
}

# A connection edge in which each node is a `Product` object
type ProductEdge {
  # The cursor that represents this node in the paginated results
  cursor: ConnectionCursor!

  # The product
  node: Product
}

# A filter to be applied to a Catalog query
input CatalogBooleanFilter {
  # The name of the filter
  name: CatalogBooleanFilterName!

  # The filter value
  value: Boolean!
}

# The list of currently supported top level Catalog props on which catalog items can be filtered.
enum CatalogBooleanFilterName {
  # isLowQuantity
  isLowQuantity

  # isSoldOut
  isSoldOut

  # isBackorder
  isBackorder

  # isDeleted
  isDeleted

  # isVisible
  isVisible
}

# Allowed values for sorting catalog items
enum CatalogItemSortByField {
  # Sort by item ID
  _id

  # Sort by date and time at which the item was created
  createdAt

  # Sort in the shop-defined order for the tag filter
  featured

  # Sort by price
  minPrice

  # Sort by date and time at which the item was last updated
  updatedAt
}

# Wraps a list of `CatalogItem`s, providing pagination cursors and information.
#
# For information about what Relay-compatible connections are and how to use them, see the following articles:
# - [Relay Connection Documentation](https://facebook.github.io/relay/docs/en/graphql-server-specification.html#connections)
# - [Relay Connection Specification](https://facebook.github.io/relay/graphql/connections.htm)
# - [Using Relay-style Connections With Apollo Client](https://www.apollographql.com/docs/react/recipes/pagination.html)
type CatalogItemConnection {
  # The list of nodes that match the query, wrapped in an edge to provide a cursor string for each
  edges: [CatalogItemEdge]

  # You can request the `nodes` directly to avoid the extra wrapping that `NodeEdge` has,
  # if you know you will not need to paginate the results.
  nodes: [CatalogItem]

  # Information to help a client request the next or previous page
  pageInfo: PageInfo!

  # The total number of nodes that match your query
  totalCount: Int!
}

# A connection edge in which each node is a `CatalogItem` object
type CatalogItemEdge {
  # The cursor that represents this node in the paginated results
  cursor: ConnectionCursor!

  # The catalog item
  node: CatalogItem
}

# Catalog items are combined to create a catalog. Each item can represent a different type of content.
interface CatalogItem {
  # Item ID
  _id: ID!

  # Date and time at which the item was created
  createdAt: DateTime

  # Shop that owns the item
  shop: Shop!

  # Date and time at which the item was last updated
  updatedAt: DateTime
}

# Represents a catalog item that displays a product
type CatalogItemProduct implements CatalogItem & Node {
  # The CatalogItemProduct ID
  _id: ID!

  # The date and time at which this CatalogItem was first created, which is when the related product was first published
  createdAt: DateTime!

  # The catalog product
  product: CatalogProduct

  # The shop to which this catalog belongs
  shop: Shop!

  # The date and time at which this CatalogItem was last updated, which is when the related product was most recently published
  updatedAt: DateTime!
}

# Represents a product that has been published into a shop catalog. The related `Product` is the source of truth for
# shop administrators, but that is then published to a catalog as a `CatalogProduct`, which is what should
# be displayed to shoppers who browse that catalog.
type CatalogProduct implements CatalogProductOrVariant & Node {
  # The CatalogProduct ID. Do not assume that this is the same as the related product ID. See `productId` for that.
  _id: ID!

  # The product barcode value, if it has one
  barcode: String

  # The date and time at which this CatalogProduct was created, which is when the related product was first published
  createdAt: DateTime!

  # The full product description, which may have newline characters in it
  description: String

  # The height of the product, if it has physical dimensions
  height: Float

  # True if this product has been deleted. Typically, deleted products are not returned in queries.
  isDeleted: Boolean!

  # True if this product should be shown to shoppers. Typically, non-visible products are not returned in queries.
  isVisible: Boolean!

  # The length of the product, if it has physical dimensions
  length: Float

  # All media for this product and its variants
  media: [ImageInfo]

  # The product description to use for page `description` meta element in HTML
  metaDescription: String

  # Arbitrary additional metadata about this product
  metafields: [Metafield]

  # The minimum quantity that must be added to a cart
  minOrderQuantity: Int

  # The country of origin
  originCountry: String

  # Subtitle
  pageTitle: String

  # Dimensions and other information about the containers in which this product will be shipped
  parcel: ShippingParcel

  # The primary image
  primaryImage: ImageInfo

  # The related Product ID
  productId: ID!

  # An arbitrary product type value, such as from an external system
  productType: String

  # The shop to which this product belongs
  shop: Shop!

  # A stock keeping unit (SKU) identifier for this product
  sku: String

  # A URL-safe and human-readable string that uniquely identifies this product
  slug: String

  # Holds metadata specific to a specific social network service
  socialMetadata: [SocialMetadata]

  # When a shopper purchases this product, what types of fulfillment can they choose from?
  supportedFulfillmentTypes: [FulfillmentType]!

  # Product title
  title: String

  # The date and time at which this CatalogProduct was last updated, which is when the related product was most recently published
  updatedAt: DateTime!

  # A flat list of all variants for this product
  variants: [CatalogProductVariant]

  # The product vendor or manufacturer, for display
  vendor: String

  # The weight of the product on Earth, if it has physical dimensions
  weight: Float

  # The width of the product, if it has physical dimensions
  width: Float

  # The list of tag IDs that have been applied to this product
  tagIds: [ID]

  # The list of tags that have been applied to this product
  tags(
    # Return only results that come after this cursor. Use this with `first` to specify the number of results to return.
    after: ConnectionCursor

    # Return only results that come before this cursor. Use this with `last` to specify the number of results to return.
    before: ConnectionCursor

    # Return at most this many results. This parameter may be used with either `after` or `offset` parameters.
    first: ConnectionLimitInt

    # Return at most this many results. This parameter may be used with the `before` parameter.
    last: ConnectionLimitInt

    # Return only results that come after the Nth result. This parameter may be used with the `first` parameter.
    offset: Int

    # Return results sorted in this order
    sortOrder: SortOrder = asc

    # By default, tags are sorted by ID. Set this to sort by one of the other allowed fields
    sortBy: TagSortByField = _id
  ): TagConnection

  # Price and related information, per currency
  pricing: [ProductPricingInfo]!

  # True if every purchasable variant of this product is sold out but allows backorders. A storefront UI may use this
  # to decide to show a "Backordered" indicator.
  isBackorder: Boolean!

  # True if at least one purchasable variant of this product has a low quantity in stock. A storefront UI may use this
  # to decide to show a "Low Quantity" indicator.
  isLowQuantity: Boolean!

  # True if every purchasable variant of this product is sold out. A storefront UI may use this
  # to decide to show a "Sold Out" indicator when `isBackorder` is not also true.
  isSoldOut: Boolean!
}

# This interface represents the fields that are identical for both Products and Variants
interface CatalogProductOrVariant {
  # The product barcode value, if it has one
  barcode: String

  # The date and time at which this CatalogProduct was created, which is when the related product was first published
  createdAt: DateTime

  # The height of the product, if it has physical dimensions
  height: Float

  # The length of the product, if it has physical dimensions
  length: Float

  # Arbitrary additional metadata about this product
  metafields: [Metafield]

  # The minimum quantity that must be added to a cart
  minOrderQuantity: Int

  # The country of origin
  originCountry: String

  # The shop to which this product belongs
  shop: Shop!

  # A stock keeping unit (SKU) identifier for this product
  sku: String

  # Product or variant title
  title: String

  # The date and time at which this CatalogProduct was last updated, which is when the related product was most recently published
  updatedAt: DateTime

  # The weight of the product on Earth, if it has physical dimensions
  weight: Float

  # The width of the product, if it has physical dimensions
  width: Float
}

# A shipping parcel
type ShippingParcel {
  # Containers
  containers: String

  # Distance unit
  distanceUnit: DistanceUnit

  # Height
  height: Float

  # Length
  length: Float

  # Mass unit
  massUnit: MassUnit

  # Weight
  weight: Float

  # Width
  width: Float
}

# Distance units
enum DistanceUnit {
  # Centimeter
  cm

  # Foot
  ft

  # Inch
  in
}

# Mass units
enum MassUnit {
  # Gram
  g

  # Kilogram
  kg

  # Pound
  lb

  # Ounce
  oz
}

# A variant of a catalog product
type CatalogProductVariant implements CatalogProductOrVariant & Node {
  # The CatalogProductVariant ID. Do not assume that this is the same as the related variant ID. See `variantId` for that.
  _id: ID!

  # The attribute label describes the category of variant, for example, `Color` or `Size`.
  # In most cases this will be the same for all variants at the same level.
  attributeLabel: String!

  # The product variant barcode value, if it has one
  barcode: String

  # The date and time at which this CatalogProductVariant was created, which is when the related product was first published
  createdAt: DateTime

  # The height of the product variant, if it has physical dimensions
  height: Float

  # The position of this variant among other variants at the same level of the product-variant-option hierarchy
  index: Int!

  # The length of the product, if it has physical dimensions
  length: Float

  # All media for this variant / option
  media: [ImageInfo]

  # Arbitrary additional metadata about this product
  metafields: [Metafield]

  # The minimum quantity that must be added to a cart
  minOrderQuantity: Int

  # A short title to use for product detail select lists
  optionTitle: String

  # Child variants, if any
  options: [CatalogProductVariant]

  # The country of origin
  originCountry: String

  # The primary image of this variant / option
  primaryImage: ImageInfo

  # The shop to which this product variant belongs
  shop: Shop!

  # A stock keeping unit (SKU) identifier for this product
  sku: String

  # The full variant title for use on cart, checkout, and order summaries and on invoices.
  # This fully describes the configured variant. For example, if this is an option with
  # `optionTitle` `Large`, its parent variant has `optionTitle` `Red`, and the product
  # `title` is `Fancy T-Shirt`, then this `title` will be something like `Fancy T-Shirt - Red - Large`.
  title: String

  # The date and time at which this CatalogProduct was last updated, which is when the related product was most recently published
  updatedAt: DateTime

  # The related Variant ID
  variantId: ID!

  # The weight of the product on Earth, if it has physical dimensions
  weight: Float

  # The width of the product, if it has physical dimensions
  width: Float

  # Price and related information, per currency
  pricing: [ProductPricingInfo]!

  # True for a purchasable variant if an order containing this variant will be accepted even when there is insufficient
  # available inventory (`inventoryAvailableToSell`) to fulfill it immediately. For non-purchasable variants, this is true if at least one purchasable
  # child variant can be backordered. A storefront UI may use this in combination with `inventoryAvailableToSell` to
  # decide whether to show or enable an "Add to Cart" button.
  canBackorder: Boolean!

  # The quantity of this item currently available to sell.
  # This number is updated when an order is placed by the customer.
  # This number does not include reserved inventory (i.e. inventory that has been ordered, but not yet processed by the operator).
  # If this is a variant, this number is created by summing all child option inventory numbers.
  # This is most likely the quantity to display in the storefront UI.
  inventoryAvailableToSell: Int

  # The quantity of this item currently in stock.
  # This number is updated when an order is processed by the operator.
  # This number includes all inventory, including reserved inventory (i.e. inventory that has been ordered, but not yet processed by the operator).
  # If this is a variant, this number is created by summing all child option inventory numbers.
  # This is most likely just used as a reference in the operator UI, and not displayed in the storefront UI.
  inventoryInStock: Int

  # True for a purchasable variant if it is sold out but allows backorders. For non-purchasable variants, this is
  # true if every purchasable child variant is sold out but allows backorders. A storefront UI may use this
  # to decide to show a "Backordered" indicator.
  isBackorder: Boolean!

  # True for a purchasable variant if it has a low available quantity (`inventoryAvailableToSell`) in stock.
  # For non-purchasable variants, this is true if at least one purchasable child variant has a low available
  # quantity in stock. A storefront UI may use this to decide to show a "Low Quantity" indicator.
  isLowQuantity: Boolean!

  # True for a purchasable variant if it is sold out (`inventoryAvailableToSell` is 0). For non-purchasable
  # variants, this is true if every purchasable child variant is sold out. A storefront UI may use this
  # to decide to show a "Sold Out" indicator when `isBackorder` is not also true.
  isSoldOut: Boolean!

  # Is sales tax charged on this item?
  isTaxable: Boolean!

  # An optional code which, if understood by the active tax service for the shop, determines how this product should be taxed
  taxCode: String

  # A description to use for the tax line item on an invoice
  taxDescription: String
}

# Wraps an array of vendors, providing pagination cursors and information.
#
# For information about what Relay-compatible connections are and how to use them, see the following articles:
# - [Relay Connection Documentation](https://facebook.github.io/relay/docs/en/graphql-server-specification.html#connections)
# - [Relay Connection Specification](https://facebook.github.io/relay/graphql/connections.htm)
# - [Using Relay-style Connections With Apollo Client](https://www.apollographql.com/docs/react/recipes/pagination.html)
type VendorConnection {
  # The list of nodes that match the query, wrapped in an edge to provide a cursor string for each
  edges: [VendorEdge]

  # You can request the `nodes` directly to avoid the extra wrapping that `NodeEdge` has,
  # if you know you will not need to paginate the results.
  nodes: [Vendor]

  # Information to help a client request the next or previous page
  pageInfo: PageInfo!

  # The total number of nodes that match your query
  totalCount: Int!
}

# A connection edge in which each node is a String representing a vendor
type VendorEdge {
  # The cursor that represents this node in the paginated results
  cursor: ConnectionCursor!

  # The vendor
  node: Vendor
}

#
type Vendor {
  # The name of the vendor
  name: String
}

# Wraps a list of `TagProduct`s, providing pagination cursors and information.
#
# For information about what Relay-compatible connections are and how to use them, see the following articles:
# - [Relay Connection Documentation](https://facebook.github.io/relay/docs/en/graphql-server-specification.html#connections)
# - [Relay Connection Specification](https://facebook.github.io/relay/graphql/connections.htm)
# - [Using Relay-style Connections With Apollo Client](https://www.apollographql.com/docs/react/recipes/pagination.html)
type TagProductConnection {
  # The list of nodes that match the query, wrapped in an edge to provide a cursor string for each
  edges: [TagProductEdge]

  # You can request the `nodes` directly to avoid the extra wrapping that `NodeEdge` has,
  # if you know you will not need to paginate the results.
  nodes: [TagProduct]

  # Information to help a client request the next or previous page
  pageInfo: PageInfo!

  # The total number of nodes that match your query
  totalCount: Int!
}

# A connection edge in which each node is a `TagProduct` object
type TagProductEdge {
  # The cursor that represents this node in the paginated results
  cursor: ConnectionCursor!

  # The tag product
  node: TagProduct
}

# A tag product
type TagProduct {
  # The product id
  _id: ID!

  # The date and time at which this CatalogProduct was created, which is when the related product was first published
  createdAt: DateTime!

  # Position of the product
  position: Int

  # The title of the product
  title: String
}

# Input that defines a single configuration of a product
input ProductConfigurationInput {
  # The Product ID
  productId: ID!

  # The ProductVariant ID
  productVariantId: ID!
}

# Inventory info for a specific product configuration. For inventory managed by the SimpleInventory plugin.
type SimpleInventoryInfo {
  # Whether to allow ordering this product configuration when there is insufficient quantity available
  canBackorder: Boolean

  # Current quantity of this product configuration in stock
  inventoryInStock: Int

  # Current quantity of this product configuration unavailable for ordering. This value is calculated
  # by the system based on this product variant being in not-yet-approved orders.
  inventoryReserved: Int

  # Whether the SimpleInventory plugin should manage inventory for this product configuration
  isEnabled: Boolean

  # The "low quantity" flag will be applied to this product configuration when the available quantity
  # is at or below this threshold
  lowInventoryWarningThreshold: Int

  # The product and chosen options this info applies to
  productConfiguration: ProductConfiguration!
}

# Product configuration data
type ProductConfiguration {
  # The Product ID
  productId: ID!

  # The ProductVariant ID
  productVariantId: ID!
}

# The cart holds selected items until order is placed.
type Cart implements Node {
  # The Cart ID
  _id: ID!

  # The account that owns the cart. Some carts are created for anonymous users. Anonymous carts have a null account.
  # Every account has exactly one cart per shop.
  account: Account

  # Holds all information collected for a cart during checkout
  checkout: Checkout

  # The date and time at which the cart was created, which is when the first item was added to it.
  createdAt: DateTime!

  # An email address that has been associated with the cart
  email: String

  # The date and time at which the cart will expire. Account carts usually do not expire, so they will have a null value here.
  expiresAt: DateTime

  # The items that have been added to the cart. A cart is not created until the first item is added. Items can be removed from a cart, and a cart is not deleted if all items are removed from it. Because all items may have been removed, this may be an empty array.
  items(
    # Return only results that come after this cursor. Use this with `first` to specify the number of results to return.
    after: ConnectionCursor

    # Return only results that come before this cursor. Use this with `last` to specify the number of results to return.
    before: ConnectionCursor

    # Return at most this many results. This parameter may be used with either `after` or `offset` parameters.
    first: ConnectionLimitInt

    # Return at most this many results. This parameter may be used with the `before` parameter.
    last: ConnectionLimitInt

    # Return only results that come after the Nth result. This parameter may be used with the `first` parameter.
    offset: Int

    # Return results sorted in this order
    sortOrder: SortOrder = desc

    # By default, items are sorted by when they were added to the cart, newest first. Set this to sort by one of the other allowed fields
    sortBy: CartItemsSortByField = addedAt
  ): CartItemConnection

  # If any products or variants become hidden or are deleted after they were added to this cart, they'll be
  # automatically moved from `items` to `missingItems`. Clients may want to use this to show an
  # "items that are no longer available" list to storefront users.
  #
  # If a product becomes visible again, the item will never be automatically moved from `missingItems`
  # back to `items`, but clients may want to provide a way for users to manually do this.
  missingItems: [CartItem]

  # If you integrate with third-party systems that require you to send the same ID for order
  # calculations as for cart calculations, you may use this ID, which is the same on a `cart` as on
  # the `order` placed from that cart. This ID can also be customized by plugins and is the best
  # ID to use if it is necessary to show a cart ID in the user interface.
  referenceId: String

  # The shop that owns the cart.
  shop: Shop!

  # Total quantity of all items in the cart
  totalItemQuantity: Int!

  # The date and time at which this cart was last updated.
  updatedAt: DateTime!

  # Surcharges applied to this cart
  surcharges: [AppliedSurcharge]!

  # A summary of calculated taxes for this cart. Null means "not able to calculate",
  # such as when no fulfillment method has been selected for some fulfillment groups.
  taxSummary: TaxSummary
}

# Holds all information collected for a cart during checkout
type Checkout {
  # One or more fulfillment groups, for example, mapping certain items to certain shipping addresses
  fulfillmentGroups: [FulfillmentGroup]!

  # A summary of the totals for this cart
  summary: CartSummary!
}

# Links one or more cart items to fulfillment data. The most common example is having one FulfillmentGroup
# per shipping address.
type FulfillmentGroup implements Node {
  # The fulfillment ID
  _id: ID!

  # The list of fulfillment options from which the shopper may choose. This list is created by taking
  # the full list of registered fulfillment methods, keeping only those that match the fulfillment `type`
  # of this group, and then calculating a price and handlingPrice for each based on the `items` in this group.
  availableFulfillmentOptions: [FulfillmentOption]!

  # Information needed by the fulfillment type to properly fulfill the order
  data: FulfillmentData

  # The items that are included in this fulfillment group
  items: [CartItem]!

  # The fulfillment method selected by a shopper for this group, with its associated price
  selectedFulfillmentOption: FulfillmentOption

  # The shipping address collected for this group, if relevant
  shippingAddress: Address

  # The shop that owns the items in this group and is responsible for fulfillment
  shop: Shop!

  # The fulfillment type. Any valid type that has been registered by a fulfillment plugin. Examples: `shipping`, `digital`
  type: FulfillmentType!
}

# A fulfillment option for a cart fulfillment group, which is a method with an associated price
type FulfillmentOption {
  # The fulfillment method this pricing is for
  fulfillmentMethod: FulfillmentMethod

  # The additional amount charged for handling
  handlingPrice: Money!

  # The base price charged
  price: Money!
}

# A single fulfillment method. Fulfillment methods are shown to shoppers along with a quote for them,
# and the shopper chooses one method per fulfillment group per cart during checkout.
type FulfillmentMethod implements Node {
  # The fulfillment method ID
  _id: ID!

  # A carrier name
  carrier: String

  # The name of this method, for display in the user interface
  displayName: String!

  # The fulfillment types for which this method may be used. For example, `shipping` or `digital`.
  fulfillmentTypes: [FulfillmentType]!

  # The group to which this method belongs
  group: String

  # The name of this method, a unique identifier
  name: String!
}

# Information needed by the selected fulfillment method to properly fulfill the order
type FulfillmentData {
  # The mailing address to which this fulfillment group should be shipped
  shippingAddress: Address
}

# A single item in a cart. The item contains information about an intended purchase.
type CartItem implements Node {
  # The quantity of this item currently available to sell.
  # This number is updated when an order is placed by the customer.
  # This number does not include reserved inventory (i.e. inventory that has been ordered, but not yet processed by the operator).
  # This is most likely the quantity to display in the storefront UI.
  inventoryAvailableToSell: Int

  # True if this item is currently sold out but allows backorders. A storefront UI may use this
  # to decide to show a "Backordered" indicator.
  isBackorder: Boolean!

  # True if this item has a low available quantity (`inventoryAvailableToSell`) in stock.
  # A storefront UI may use this to decide to show a "Low Quantity" indicator.
  isLowQuantity: Boolean!

  # True if this item is currently sold out (`inventoryAvailableToSell` is 0). A storefront
  # UI may use this to decide to show a "Sold Out" indicator when `isBackorder` is not also true.
  isSoldOut: Boolean!

  # The cart item ID
  _id: ID!

  # "
  # The date and time at which this item was first added to the associated cart.
  # If an item is added, removed, and then added again, this will reflect the most recent addition.
  # However, if an item is added twice, the quantity will increase but this date will remain
  # the initial added date.
  addedAt: DateTime!

  # FUTURE. Additional attributes of the chosen item. For example, if this item is for a product, socks, where `blue` and `small`
  # options were chosen for some configurable attributes, then `color:blue` and `size:small` will be indicated here.
  attributes: [CartItemAttribute]

  # The current comparison (e.g., MSRP) price of the item
  compareAtPrice: Money

  # The date and time at which the cart item was created. If an item is added, removed, and then added again,
  # the original item is destroyed and this field will reflect the time it was created for the most recent addition.
  createdAt: DateTime!

  # The URLs for a picture of the item in various sizes
  imageURLs: ImageSizes

  # Arbitrary additional metadata about this cart item.
  metafields: [Metafield]

  # The selected variant optionTitle
  optionTitle: String

  # Packing information such as item weight, height, length, and depth. Used for calculating shipping rates.
  parcel: ShippingParcel

  # The current price of the item
  price: Money!

  # The price at which this item was listed when it was added to the cart
  priceWhenAdded: Money!

  # The product and chosen options
  productConfiguration: ProductConfiguration!

  # The product's slug
  productSlug: String

  # The list of tags that have been applied to this product
  productTags(
    # Return only results that come after this cursor. Use this with `first` to specify the number of results to return.
    after: ConnectionCursor

    # Return only results that come before this cursor. Use this with `last` to specify the number of results to return.
    before: ConnectionCursor

    # Return at most this many results. This parameter may be used with either `after` or `offset` parameters.
    first: ConnectionLimitInt

    # Return at most this many results. This parameter may be used with the `before` parameter.
    last: ConnectionLimitInt

    # Return only results that come after the Nth result. This parameter may be used with the `first` parameter.
    offset: Int

    # Return results sorted in this order
    sortOrder: SortOrder = asc

    # By default, tags are sorted by ID. Set this to sort by one of the other allowed fields
    sortBy: TagSortByField = _id
  ): TagConnection

  # The type of product, used to display cart items differently
  productType: String

  # The product vendor
  productVendor: String

  # The quantity of this item that has been added to the cart. This must be a positive integer. Remove this `CartItem` from it's associated cart if you want `0` of this item.
  quantity: Int!

  # The shop associated with this cart item.
  shop: Shop!

  # The current price of the item multiplied by the quantity
  subtotal: Money!

  # A title for use in cart/orders that conveys the selected product's title + chosen options
  title: String!

  # The date and time at which this item was last updated
  updatedAt: DateTime!

  # The selected variant title
  variantTitle: String

  # Is this a taxable item?
  isTaxable: Boolean!

  # Total tax calculated for this item
  tax: Money

  # The tax code for this item
  taxCode: String

  # Amount of subtotal that is taxable
  taxableAmount: Money

  # List of calculated taxes due for this item
  taxes: [CalculatedTax]
}

# One attribute of a cart item
type CartItemAttribute {
  # The attribute label, e.g., Color
  label: String

  # The attribute value, e.g., Blue
  value: String
}

# A single calculated tax for a cart, order group, cart item, or order item
type CalculatedTax {
  # Calculated tax ID
  _id: ID!

  # Jurisdiction ID. It is up to the tax service to determine if and how to use this.
  jurisdictionId: String

  # Did this tax match due to the order origin or the order destination?
  sourcing: TaxSource!

  # Amount of tax due
  tax: Money!

  # A human-readable display name for showing this tax to operators and customers in the UI
  taxName: String!

  # The tax rate used for this calculation
  taxRate: Rate!

  # Amount that was used for calculating the tax due
  taxableAmount: Money!
}

# Tax sources
enum TaxSource {
  # Tax is applied when the destination matches the tax jurisdiction
  destination

  # Tax is applied when the origin matches the tax jurisdiction
  origin
}

# A numeric rate, with its corresponding percent values
type Rate {
  # The rate
  amount: Float!

  # The percent as a preformatted string with percent symbol included
  displayPercent: String!

  # The percent (rate x 100)
  percent: Float!
}

# A summary of the totals for this cart
type CartSummary {
  # The total of all discounts applied, as a positive number
  discountTotal: Money!

  # The calculated tax-exclusive tax rate on all items and fulfillment prices (taxTotal / taxableAmount).
  # This may be null, and there is a difference between null and 0. Null means `not able to calculate`,
  # such as when no fulfillment method has been selected for some fulfillment groups.
  effectiveTaxRate: Rate

  # The total price of all chosen fulfillment methods. This may be null, and there is a difference
  # between null and 0. Null means `not able to calculate`, such as when no fulfillment method has
  # been selected for some fulfillment groups.
  fulfillmentTotal: Money

  # The combined prices of all cart items
  itemTotal: Money!

  # The total estimated tax that has not already been included in the item prices. This may be null,
  # and there is a difference between null and 0. Null means `not able to calculate`, such as when no
  # fulfillment methods have been selected or there is some other issue with the tax service.
  taxTotal: Money

  # The total amount that was deemed taxable by the tax service
  taxableAmount: Money!

  # The sum of `itemTotal`, `fulfillmentTotal`, and `taxTotal`, minus `discountTotal`
  total: Money!

  # The combined total of all surcharges. This may be null, and there is a difference
  # between null and 0. Null means `not able to calculate`, such as when no fulfillment method has
  # been selected for some fulfillment groups.
  surchargeTotal: Money
}

# Allowed values for cart item sortBy parameter
enum CartItemsSortByField {
  # Cart item ID
  _id

  # Date and time at which the item was added to the cart
  addedAt
}

# Wraps a list of `CartItem`s, providing pagination cursors and information.
#
# For information about what Relay-compatible connections are and how to use them, see the following articles:
# - [Relay Connection Documentation](https://facebook.github.io/relay/docs/en/graphql-server-specification.html#connections)
# - [Relay Connection Specification](https://facebook.github.io/relay/graphql/connections.htm)
# - [Using Relay-style Connections With Apollo Client](https://www.apollographql.com/docs/react/recipes/pagination.html)
type CartItemConnection {
  # The list of nodes that match the query, wrapped in an edge to provide a cursor string for each
  edges: [CartItemEdge]

  # You can request the `nodes` directly to avoid the extra wrapping that `NodeEdge` has,
  # if you know you will not need to paginate the results.
  nodes: [CartItem]

  # Information to help a client request the next or previous page
  pageInfo: PageInfo!

  # The total number of nodes that match your query
  totalCount: Int!
}

# A connection edge in which each node is a `CartItem` object
type CartItemEdge implements NodeEdge {
  # The cursor that represents this node in the paginated results
  cursor: ConnectionCursor!

  # The cart item
  node: CartItem
}

# Defines a surcharge that has been applied to a Cart or Order
type AppliedSurcharge implements Node {
  # The surcharge ID
  _id: ID!

  # The amount of the surcharge
  amount: Money!

  # The fulfillmentGroupId (for reference)
  fulfillmentGroupId: ID

  # The message to explain the surchage to customers, translated (if available) based on shop language
  message(
    # The language in which you want the message. If no translation is available for this language,
    # it will be in the default language of the related shop.
    language: String!
  ): String

  # The surchargeId from the surchages collection (for reference)
  surchargeDefinitionId: ID!
}

# A summary of tax-related calculations for a cart or order group
type TaxSummary {
  # The time at which taxes were last calculated for the cart or order group
  calculatedAt: DateTime!

  # The name of the tax service that last calculated taxes for the cart or order group
  calculatedByTaxServiceName: String

  # A reference ID for the external system that calculated the taxes
  referenceId: String

  # Total tax calculated by the active tax service
  tax: Money!

  # Amount that was deemed subject to any taxes by the active tax service
  taxableAmount: Money!

  # Full list of all taxes that were calculated by the active tax service for the cart or order group
  taxes: [CalculatedTax]!
}

# An order
type Order implements Node {
  # The Order ID
  _id: ID!

  # The account that placed the order. Some orders are created for anonymous users. Anonymous orders have a null account.
  account: Account

  # Full name(s) involved with payment. Payment can be made by one or more than one person
  billingName: String

  # The ID of the cart that created this order. Carts are deleted after becoming orders, so this is just a reference.
  cartId: ID

  # The date and time at which the cart was created, which is when the first item was added to it.
  createdAt: DateTime!

  # The order status for display in UI
  displayStatus(
    # The language in which you want the status. If no translation is available for this language,
    # it will be in the default language of the shop that owns the order.
    language: String!
  ): String!

  # An email address that has been associated with the cart
  email: String

  # One or more fulfillment groups. Each of these are fulfilled and charged as separate orders.
  fulfillmentGroups: [OrderFulfillmentGroup]!

  # Notes about the order. This will always return an array but it may be empty
  notes: [OrderNote]!

  # Payments that collectively have paid or will pay for the total amount due for this order.
  # May be null if no payment is needed.
  payments: [Payment]

  # An ID by which the customer can reference this order when enquiring about it. A storefront user
  # interface may show this to customers. Do not display other IDs (`_id`) to customers.
  referenceId: String!

  # Refunds that have been applied to the payments on this order.
  refunds: [Refund]

  # The shop through which the order was placed
  shop: Shop!

  # The machine-readable order status.
  status: String!

  # A summary of the totals for all fulfillment groups for this order
  summary: OrderSummary!

  # Total quantity of all items in the order
  totalItemQuantity: Int!

  # The date and time at which this order was last updated
  updatedAt: DateTime!

  # Surcharges applied to this order
  surcharges: [AppliedSurcharge]!
}

# An order fulfillment group
type OrderFulfillmentGroup implements Node {
  # The order fulfillment group ID
  _id: ID!

  # Information needed by the selected fulfillment method to properly fulfill the order
  data: OrderFulfillmentGroupData

  # The order status for display in UI
  displayStatus(
    # The language in which you want the status. If no translation is available for this language,
    # it will be in the default language of the shop that owns the order.
    language: String!
  ): String!

  # The items that are part of this fulfillment group
  items(
    # Return only results that come after this cursor. Use this with `first` to specify the number of results to return.
    after: ConnectionCursor

    # Return only results that come before this cursor. Use this with `last` to specify the number of results to return.
    before: ConnectionCursor

    # Return at most this many results. This parameter may be used with either `after` or `offset` parameters.
    first: ConnectionLimitInt

    # Return at most this many results. This parameter may be used with the `before` parameter.
    last: ConnectionLimitInt

    # Return only results that come after the Nth result. This parameter may be used with the `first` parameter.
    offset: Int

    # Return results sorted in this order
    sortOrder: SortOrder = desc

    # By default, order items are sorted by when they were added to the order, newest first. Set this to sort by one of the other allowed fields
    sortBy: OrderFulfillmentGroupItemsSortByField = addedAt
  ): OrderItemConnection

  # The fulfillment method that was selected, with its price quote
  selectedFulfillmentOption: FulfillmentOption!

  # The shipping label URL
  shippingLabelUrl: String

  # The shop responsible for fulfilling this order
  shop: Shop!

  # The machine-readable fulfillment group status.
  status: String!

  # A summary of the totals for this group
  summary: OrderSummary!

  # Total quantity of all items in the group
  totalItemQuantity: Int!

  # The order fulfillment group shipment tracking number
  tracking: String

  # The order fulfillment group shipment tracking URL
  trackingUrl: String

  # The fulfillment type. Any valid type that has been registered by a fulfillment plugin. Examples: `shipping`, `digital`
  type: FulfillmentType!

  # A summary of calculated taxes for this group.
  taxSummary: TaxSummary
}

# Extra data for an order fulfillment group
union OrderFulfillmentGroupData = ShippingOrderFulfillmentGroupData

# Extra data for an order fulfillment group with type `shipping`
type ShippingOrderFulfillmentGroupData {
  # The address to ship to
  shippingAddress: Address!
}

# Allowed values for the `OrderFulfillmentGroupItems` sortBy parameter
enum OrderFulfillmentGroupItemsSortByField {
  # Sort by the item ID
  _id

  # Sort by the date and time when the item was added to the order
  addedAt
}

# Wraps a list of `OrderItem`s, providing pagination cursors and information.
#
# For information about what Relay-compatible connections are and how to use them, see the following articles:
# - [Relay Connection Documentation](https://facebook.github.io/relay/docs/en/graphql-server-specification.html#connections)
# - [Relay Connection Specification](https://facebook.github.io/relay/graphql/connections.htm)
# - [Using Relay-style Connections With Apollo Client](https://www.apollographql.com/docs/react/recipes/pagination.html)
type OrderItemConnection {
  # The list of nodes that match the query, wrapped in an edge to provide a cursor string for each
  edges: [OrderItemEdge]

  # You can request the `nodes` directly to avoid the extra wrapping that `NodeEdge` has,
  # if you know you will not need to paginate the results.
  nodes: [OrderItem]

  # Information to help a client request the next or previous page
  pageInfo: PageInfo!

  # The total number of nodes that match your query
  totalCount: Int!
}

# A connection edge in which each node is a `OrderItem` object
type OrderItemEdge implements NodeEdge {
  # The cursor that represents this node in the paginated results
  cursor: ConnectionCursor!

  # The order item
  node: OrderItem
}

# A single item in an order. The item contains information about a purchase.
type OrderItem implements Node {
  # The order item ID
  _id: ID!

  # "
  # The date and time at which this item was first added to the associated cart.
  # If an item is added, removed, and then added again, this will reflect the most recent addition.
  # However, if an item is added twice, the quantity will increase but this date will remain
  # the initial added date.
  addedAt: DateTime

  # FUTURE. Additional attributes of the chosen item. For example, if this item is for a product, socks, where `blue` and `small`
  # options were chosen for some configurable attributes, then `color:blue` and `size:small` will be indicated here.
  attributes: [OrderItemAttribute]

  # If this order item is canceled, the reason for cancelation, if provided
  cancelReason: String

  # The date and time at which the order item was created
  createdAt: DateTime!

  # The URLs for a picture of the item in various sizes
  imageURLs: ImageSizes

  # Arbitrary additional metadata about this cart item.
  metafields: [Metafield]

  # The short title of the associated option, if this is an option item
  optionTitle: String

  # Packing information such as item weight, height, length, and depth. Used for calculating shipping rates.
  parcel: ShippingParcel

  # The price of the item at the time of purchase
  price: Money!

  # The product and chosen options
  productConfiguration: ProductConfiguration!

  # The product's slug
  productSlug: String

  # The list of tags that have been applied to this product
  productTags(
    # Return only results that come after this cursor. Use this with `first` to specify the number of results to return.
    after: ConnectionCursor

    # Return only results that come before this cursor. Use this with `last` to specify the number of results to return.
    before: ConnectionCursor

    # Return at most this many results. This parameter may be used with either `after` or `offset` parameters.
    first: ConnectionLimitInt

    # Return at most this many results. This parameter may be used with the `before` parameter.
    last: ConnectionLimitInt

    # Return only results that come after the Nth result. This parameter may be used with the `first` parameter.
    offset: Int

    # Return results sorted in this order
    sortOrder: SortOrder = asc

    # By default, tags are sorted by ID. Set this to sort by one of the other allowed fields
    sortBy: TagSortByField = _id
  ): TagConnection

  # The type of product, used to display cart items differently
  productType: String

  # The product vendor
  productVendor: String

  # The quantity of this item that has been added to the cart. This must be a positive integer. Remove this `CartItem` from it's associated cart if you want `0` of this item.
  quantity: Int!

  # The shop associated with this cart item.
  shop: Shop!

  # The machine-readable order item status.
  status: String!

  # The price of the item multiplied by the quantity of this item ordered
  subtotal: Money!

  # A title for use in orders that conveys the selected product's title + chosen options
  title: String!

  # The date and time at which this item was last updated
  updatedAt: DateTime!

  # The selected variant title
  variantTitle: String

  # Is this a taxable item?
  isTaxable: Boolean!

  # Total tax calculated for this item
  tax: Money!

  # The tax code for this item
  taxCode: String

  # Amount of subtotal that is taxable
  taxableAmount: Money!

  # List of calculated taxes due for this item
  taxes: [CalculatedTax]!
}

# One attribute of an order item
type OrderItemAttribute {
  # The attribute label, e.g., Color
  label: String

  # The attribute value, e.g., Blue
  value: String
}

# A summary of the totals for this order
type OrderSummary {
  # The total of all discounts applied, as a positive number
  discountTotal: Money!

  # The calculated tax-exclusive tax rate on all items and fulfillment prices (taxTotal / taxableAmount)
  effectiveTaxRate: Rate!

  # The total price of all chosen fulfillment methods
  fulfillmentTotal: Money!

  # The combined prices of all cart items
  itemTotal: Money!

  # The total estimated tax that has not already been included in the item prices
  taxTotal: Money!

  # The total amount that was deemed taxable by the tax service
  taxableAmount: Money!

  # The sum of `itemTotal`, `fulfillmentTotal`, and `taxTotal`, minus `discountTotal`
  total: Money!

  # The total of all suurcharges applied
  surchargeTotal: Money
}

# A note about an order
type OrderNote {
  # The account who wrote this note
  account: Account!

  # The content of the note
  content: String!

  # The date and time at which this note was created
  createdAt: DateTime!

  # The date and time at which this note was last updated
  updatedAt: DateTime!
}

# Information about a payment made
type Payment implements Node {
  # The Payment ID
  _id: ID!

  # The amount that will be applied to this payment method. If there are multiple payment methods applied to the
  # cart, this may be less than the cart total.
  amount: Money!

  # The billing address for this payment, if one was collected
  billingAddress: Address

  # If status is `error` due to a capture error, this code describes the error in a machine-readable way.
  captureErrorCode: String

  # If status is `error` due to a capture error, this code describes the error in a human-readable way.
  captureErrorMessage: String

  # For card payments, the brand of the card. Useful for showing card icons for common brands.
  cardBrand: String

  # The date and time at which this payment was created
  createdAt: DateTime!

  # The shopper-provided data needed to complete the payment using this method.
  # For example, a billing address, store credit code, stored credit card ID, etc.
  data: PaymentData

  # Use this identifier when showing this payment in a user interface
  displayName: String!

  # Has the payment authorization been canceled?
  isAuthorizationCanceled: Boolean!

  # Has the payment been captured? If false, it is just an authorization.
  isCaptured: Boolean!

  # The payment method
  method: PaymentMethod!

  # The payment mode
  mode: String

  # The payment processor
  processor: String

  # Refunds that have been applied to this payment.
  refunds: [Refund]

  # Risk level of payment
  riskLevel: RiskLevel

  # The current status of this payment
  status: PaymentStatus!

  # The payment transaction ID
  transactionId: String
}

# Data identifying a payment for an order
union PaymentData = FakeData | StripePaymentIntentData | ExampleIOUPaymentData

# Do not use this
type FakeData {
  # Do not use this
  doNotUse: String
}

# Data for a Stripe payment intent
type StripePaymentIntentData {
  # The Stripe charge ID
  chargeId: String!

  # The Stripe customer ID, if a Stripe customer exists for this charge
  customerId: String
}

# Data for an example IOU payment
type ExampleIOUPaymentData {
  # The name of the IOU payer entered by the shopper
  fullName: String!
}

# Describes a payment method
type PaymentMethod {
  # If this is `false`, the payment method does not support refunding. Use this to hide refund UI.
  canRefund: Boolean!

  # Data for this method. The data format differs for each method
  data: PaymentMethodData

  # Human-readable display name
  displayName: String!

  # Whether the payment method is enabled on a given shop
  isEnabled: Boolean!

  # The payment method name. Any valid name that has been registered by a payment plugin. e.g., saved_card
  name: String!

  # Name of the plugin that added the payment method
  pluginName: String!
}

# Any extra data needed by the payment method
union PaymentMethodData = FakeData | ExampleIOUPaymentMethodData

# Data for an example IOU payment method
type ExampleIOUPaymentMethodData {
  # Example
  example: String!
}

# A refund of a payment on an order
type Refund implements Node {
  # The refund ID
  _id: ID!

  # The amount of the refund
  amount: Money!

  # The date and time at which the refund was created
  createdAt: DateTime!

  # The display name of the payment refunded to
  paymentDisplayName: String!

  # The ID of the payment this refund is applied to
  paymentId: ID!

  # The reason for the refund
  reason: String
}

# Valid payment risk levels
enum RiskLevel {
  # An elevated risk level for a payment
  elevated

  # The highest risk level for a payment
  highest

  # A normal risk level for a payment
  normal
}

# Valid payment statuses
enum PaymentStatus {
  # A shop operator adjusted the payment amount after the order was placed
  adjustments

  # A shop operator has approved this payment
  approved

  # A shop operator has canceled this payment before it was captured
  canceled

  # A shop operator has captured this payment
  completed

  # Upon placing an order, the status of all payments for that order begins at 'created'
  created

  # There was an error capturing the payment
  error

  # A shop operator has refunded some but not all of this payment
  partialRefund

  # A shop operator has refunded all of this payment
  refunded
}

# Input type for filters to by applied to an Orders list
input OrderFilterInput {
  # A createdAt date range to filter by
  createdAt: CreatedAtInput

  # An order's fulfillment status
  fulfillmentStatus: [OrderFulfillmentStatus]

  # An order's payment status
  paymentStatus: [OrderPaymentStatus]

  # Keywords typed by the user in the search input field
  searchField: String

  # The order's status to filter by
  status: OrderStatus
}

# Input for the createdAt database field
input CreatedAtInput {
  # Start date, inclusive
  gte: DateTime

  # End date, inclusive
  lte: DateTime
}

# Available order fulfillment statuses
enum OrderFulfillmentStatus {
  # An order that has been completed
  completed

  # Newly created order that needs processing
  new

  # An order that is currently being processed
  processing
}

# Order payment status
enum OrderPaymentStatus {
  # Payments that have been successfully processed
  completed

  # A payment intent has been created
  created
}

# Order status
enum OrderStatus {
  # Canceled order
  canceled

  # A completed order
  completed

  # A new order that needs processing
  new

  # An order that is being processed
  processing
}

# The fields by which you are allowed to sort any query that returns a `OrderConnection`
enum OrdersSortByField {
  # Sort by the order ID
  _id

  # Sort by the date and time when the order was placed
  createdAt
}

# Wraps a list of `Order`s, providing pagination cursors and information.
#
# For information about what Relay-compatible connections are and how to use them, see the following articles:
# - [Relay Connection Documentation](https://facebook.github.io/relay/docs/en/graphql-server-specification.html#connections)
# - [Relay Connection Specification](https://facebook.github.io/relay/graphql/connections.htm)
# - [Using Relay-style Connections With Apollo Client](https://www.apollographql.com/docs/react/recipes/pagination.html)
type OrderConnection {
  # The list of nodes that match the query, wrapped in an edge to provide a cursor string for each
  edges: [OrderEdge]

  # You can request the `nodes` directly to avoid the extra wrapping that `NodeEdge` has,
  # if you know you will not need to paginate the results.
  nodes: [Order]

  # Information to help a client request the next or previous page
  pageInfo: PageInfo!

  # The total number of nodes that match your query
  totalCount: Int!
}

# A connection edge in which each node is a `Order` object
type OrderEdge implements NodeEdge {
  # The cursor that represents this node in the paginated results
  cursor: ConnectionCursor!

  # The order
  node: Order
}

# The fields by which you are allowed to sort any query that returns a `OrdersByAccountIdConnection`
enum OrdersByAccountIdSortByField {
  # Sort by the order ID
  _id

  # Sort by the date and time when the order was placed
  createdAt
}

# Wraps a list of `Order`s, providing pagination cursors and information.
#
# For information about what Relay-compatible connections are and how to use them, see the following articles:
# - [Relay Connection Documentation](https://facebook.github.io/relay/docs/en/graphql-server-specification.html#connections)
# - [Relay Connection Specification](https://facebook.github.io/relay/graphql/connections.htm)
# - [Using Relay-style Connections With Apollo Client](https://www.apollographql.com/docs/react/recipes/pagination.html)
type OrdersByAccountIdConnection {
  # The list of nodes that match the query, wrapped in an edge to provide a cursor string for each
  edges: [OrdersByAccountIdEdge]

  # You can request the `nodes` directly to avoid the extra wrapping that `NodeEdge` has,
  # if you know you will not need to paginate the results.
  nodes: [Order]

  # Information to help a client request the next or previous page
  pageInfo: PageInfo!

  # The total number of nodes that match your query
  totalCount: Int!
}

# A connection edge in which each node is a `Order` object
type OrdersByAccountIdEdge implements NodeEdge {
  # The cursor that represents this node in the paginated results
  cursor: ConnectionCursor!

  # The order
  node: Order
}

# Input type for filters to be applied to an discount codes list
input DiscountCodeFilterInput {
  # Keywords typed by the user in the search input field
  searchField: String
}

# Wraps a list of DiscountCode`s, providing pagination cursors and information.
#
# For information about what Relay-compatible connections are and how to use them, see the following articles:
# - [Relay Connection Documentation](https://facebook.github.io/relay/docs/en/graphql-server-specification.html#connections)
# - [Relay Connection Specification](https://facebook.github.io/relay/graphql/connections.htm)
# - [Using Relay-style Connections With Apollo Client](https://www.apollographql.com/docs/react/recipes/pagination.html)
type DiscountCodeConnection {
  # The list of nodes that match the query, wrapped in an edge to provide a cursor string for each
  edges: [DiscountCodeEdge]

  # You can request the `nodes` directly to avoid the extra wrapping that `NodeEdge` has,
  # if you know you will not need to paginate the results.
  nodes: [DiscountCode]

  # Information to help a client request the next or previous page
  pageInfo: PageInfo!

  # The total number of nodes that match your query
  totalCount: Int!
}

# A connection edge in which each node is a `DiscountCode` object
type DiscountCodeEdge {
  # The cursor that represents this node in the paginated results
  cursor: ConnectionCursor!

  # The discount code
  node: DiscountCode
}

# A discount code
type DiscountCode {
  # Discount code ID
  _id: ID!

  # How the discount should be applied
  calculation: DiscountCalculation

  # Discount Code
  code: String!

  # Discount code conditions
  conditions: DiscountConditions

  # Description to describe the discount code
  description: String

  # Discount is allowed to be string or number.
  # it's a formula value (could be shipping code)
  discount: String

  # Discount method type
  discountMethod: DiscountMethod

  # Label to describe the code
  label: String

  # The shop to which this DiscountCode belongs to
  shop: Shop!

  # History of transactions
  transactions: [DiscountTransaction]
}

# Discount code calculation
type DiscountCalculation {
  # Discount code calculation method
  method: DiscountCalculationMethod
}

# Discount calculation types
enum DiscountCalculationMethod {
  # Store credit
  credit

  # Discount of order
  discount

  # Sale on an item
  sale

  # Discount to shipping
  shipping
}

# Conditions for a discount code to be applied
type DiscountConditions {
  # Account Limit
  accountLimit: Int

  # Audience that may apply this discount code
  audience: [String]

  # Is this discount code enabled
  enabled: Boolean!

  # Order conditions
  order: DiscountConditionOrder

  # Permissions that may apply this discount code
  permissions: [String]

  # Products that may apply this discount code
  products: [String]

  # Number of times this code may be redeemed.
  # Setting to 100 means the first 100 customers may apply this code.
  # Setting this value to 0 will allow this code to be applied an infinite number of times.
  redemptionLimit: Int

  # Tags that may be apply this discount code
  tags: [String]
}

# The conditions an order must meet for a discount code to be applied
type DiscountConditionOrder {
  # Order date range end
  endDate: DateTime

  # Maximum order value
  max: Float

  # Minimum order value
  min: Float!

  # Order date range start
  startDate: DateTime
}

# Discount method types
enum DiscountMethod {
  # Code type
  code

  # Rate type
  rate
}

# Transaction history for a discount code
type DiscountTransaction {
  # Date the code was applied
  appliedAt: DateTime

  # Cart id
  cartId: String!

  # User id
  userId: String!
}

# Allowed values for surcharge `sortBy` parameter
enum SurchargeSortByField {
  # The date the surcharge definition was created
  createdAt
}

# Wraps a list of `Surcharge`s, providing pagination cursors and information.
#
# For information about what Relay-compatible connections are and how to use them, see the following articles:
# - [Relay Connection Documentation](https://facebook.github.io/relay/docs/en/graphql-server-specification.html#connections)
# - [Relay Connection Specification](https://facebook.github.io/relay/graphql/connections.htm)
# - [Using Relay-style Connections With Apollo Client](https://www.apollographql.com/docs/react/recipes/pagination.html)
type SurchargeConnection {
  # The list of nodes that match the query, wrapped in an edge to provide a cursor string for each
  edges: [SurchargeEdge]

  # You can request the `nodes` directly to avoid the extra wrapping that `NodeEdge` has,
  # if you know you will not need to paginate the results.
  nodes: [Surcharge]

  # Information to help a client request the next or previous page
  pageInfo: PageInfo!

  # Total count for all pages
  totalCount: Int!
}

# A connection edge in which each node is a `Surcharge` object
type SurchargeEdge {
  # The cursor that represents this node in the paginated results
  cursor: ConnectionCursor!

  # The surcharge
  node: Surcharge
}

# Defines a surcharge for surchargeById and surcharges query.
type Surcharge implements Node {
  # The surcharge ID.
  _id: ID!

  # Amount.
  amount: Money!

  # Attribute restrictions.
  attributes: [SurchargeAttributeRestrictions]

  # The date and time at which this surcharge was created
  createdAt: DateTime!

  # Destination restrictions.
  destination: SurchargeDestinationRestrictions

  # Message translated into provided / default language.
  message(
    # The language in which you want the message. If no translation is available for this language,
    # it will be in the default language of the related shop.
    language: String!
  ): String!

  # Messages provided with content and all languages
  messagesByLanguage: [SurchargeMessagesByLanguage]

  # Method IDs to apply this surcharge to.
  methodIds: [ID]

  # The shop ID
  shopId: ID!

  # The type of this surcharge. Allowed types `surcharge`.
  type: SurchargeTypeEnum!

  # The date and time at which this surcharge was last updated
  updatedAt: DateTime
}

# Attribute Restrictions attached to a Surcharge
type SurchargeAttributeRestrictions {
  # The operator to use for value comparison
  operator: String

  # The property to check
  property: String

  # The type of this property
  propertyType: SurchargePropertyType

  # The value to check for
  value: String
}

# A list of the possible property types for surcharges
enum SurchargePropertyType {
  # Boolean
  bool

  # Float
  float

  # Integer
  int

  # String
  string
}

# Destination restrictions attached to a surcharge. If multiple of `country`,
# `region`, and `postal` are set, there is an AND relationship.
type SurchargeDestinationRestrictions {
  # Restrict for any of these destination countries
  country: [String]

  # Restrict for any of these destination postal codes
  postal: [String]

  # Restrict for any of these destination regions
  region: [String]
}

# Object that includes translated content and language of translation
type SurchargeMessagesByLanguage {
  # The message for this language
  content: String!

  # The language code
  language: String!
}

# Allowed values for surcharge type
enum SurchargeTypeEnum {
  # Surcharge
  surcharge
}

# Defines a fulfillment method that has a fixed price. This type is provided by the `flat-rate` fulfillment plugin.
type FlatRateFulfillmentMethod implements Node {
  # The flat rate fulfillment method ID
  _id: ID!

  # The cost of this fulfillment method to the shop, if you track this
  cost: Float

  # The fulfillment types for which this method may be used. For example, `shipping` or `digital`.
  fulfillmentTypes: [FulfillmentType]!

  # The group to which this method belongs
  group: String!

  # A fixed price to charge for handling costs when this fulfillment method is selected for an order
  handling: Float!

  # Include this as a fulfillment option shown to shoppers during checkout?
  isEnabled: Boolean!

  # The name of this method, for display in the user interface
  label: String!

  # The name of this method, a unique identifier
  name: String!

  # A fixed price to charge for fulfillment costs when this fulfillment method is selected for an order
  rate: Float!

  # The shop to which this fulfillment method belongs
  shop: Shop!
}

# Wraps a list of FlatRateFulfillmentMethods`s, providing pagination cursors and information.
#
# For information about what Relay-compatible connections are and how to use them, see the following articles:
# - [Relay Connection Documentation](https://facebook.github.io/relay/docs/en/graphql-server-specification.html#connections)
# - [Relay Connection Specification](https://facebook.github.io/relay/graphql/connections.htm)
# - [Using Relay-style Connections With Apollo Client](https://www.apollographql.com/docs/react/recipes/pagination.html)
type FlatRateFulfillmentMethodConnection {
  # The list of nodes that match the query, wrapped in an edge to provide a cursor string for each
  edges: [FlatRateFulfillmentMethodEdge]

  # You can request the `nodes` directly to avoid the extra wrapping that `NodeEdge` has,
  # if you know you will not need to paginate the results.
  nodes: [FlatRateFulfillmentMethod]

  # Information to help a client request the next or previous page
  pageInfo: PageInfo!

  # The total number of nodes that match your query
  totalCount: Int!
}

# A connection edge in which each node is a `FlatRateFulfillmentMethod` object
type FlatRateFulfillmentMethodEdge {
  # The cursor that represents this node in the paginated results
  cursor: ConnectionCursor!

  # The fulfillment method
  node: FlatRateFulfillmentMethod
}

# Allowed values for `FlatRateFulfillmentRestriction` sortBy parameter
enum FlatRateFulfillmentRestrictionSortByField {
  # Date the restriction was created
  createdAt
}

# Wraps a list of `FlatRateFulfillmentRestriction`s, providing pagination cursors and information.
#
# For information about what Relay-compatible connections are and how to use them, see the following articles:
# - [Relay Connection Documentation](https://facebook.github.io/relay/docs/en/graphql-server-specification.html#connections)
# - [Relay Connection Specification](https://facebook.github.io/relay/graphql/connections.htm)
# - [Using Relay-style Connections With Apollo Client](https://www.apollographql.com/docs/react/recipes/pagination.html)
type FlatRateFulfillmentRestrictionConnection {
  # The list of nodes that match the query, wrapped in an edge to provide a cursor string for each
  edges: [FlatRateFulfillmentRestrictionEdge]

  # You can request the `nodes` directly to avoid the extra wrapping that `NodeEdge` has,
  # if you know you will not need to paginate the results.
  nodes: [FlatRateFulfillmentRestriction]

  # Information to help a client request the next or previous page
  pageInfo: PageInfo!

  # The total number of nodes that match your query
  totalCount: Int!
}

# A connection edge in which each node is a `FlatRateFulfillmentRestriction` object
type FlatRateFulfillmentRestrictionEdge {
  # The cursor that represents this node in the paginated results
  cursor: ConnectionCursor!

  # The flat rate fulfillment restriction
  node: FlatRateFulfillmentRestriction
}

# Defines a flat rate fulfillment method restriction.
type FlatRateFulfillmentRestriction implements Node {
  # The restriction ID.
  _id: ID!

  # Attribute restrictions. Multiple attribute restrictions are evaluated with AND. If both destination and attribute restrictions are present, they evaluate with AND.
  attributes: [AttributeRestrictions]

  # Destination restrictions. If multiple destination restrictions are present, the most localized is the only one evaluated (i.e. evaluate postal if present, then region if present, then country). If both destination and attribute restrictions are present, they evaluate with AND.
  destination: DestinationRestrictions

  # Method IDs to apply this restriction to. If none, applies to all methods as a universal restriction.
  methodIds: [ID]

  # The shop ID
  shopId: ID!

  # The type of this restriction. Allowed types are `allow` or `deny`.
  type: RestrictionTypeEnum!
}

# An attribute restriction condition
type AttributeRestrictions {
  # The operator to use for value comparison
  operator: String!

  # The property to check
  property: String!

  # The type of this property
  propertyType: String!

  # The value to check for
  value: String!
}

# Destination restriction conditions. If multiple of `country`,
# `region`, and `postal` are set, there is an AND relationship.
type DestinationRestrictions {
  # Restrict for any of these destination countries
  country: [String]

  # Restrict for any of these destination postal codes
  postal: [String]

  # Restrict for any of these destination regions
  region: [String]
}

# Restriction type
enum RestrictionTypeEnum {
  # Allow
  allow

  # Deny
  deny
}

# A tax code that may be used on a product to indicate proper taxation category
type TaxCode {
  # The code
  code: String!

  # Short description of what types of products the code is for
  label: String!
}

# A service registered by a tax plugin, that provides tax codes and calculations
type TaxService {
  # Human-readable display name
  displayName: String!

  # The tax service name. Any valid name that has been registered by a tax plugin.
  name: String!

  # Name of the plugin that added the tax service
  pluginName: String!
}

# Wraps a list of TaxRate`s, providing pagination cursors and information.
#
# For information about what Relay-compatible connections are and how to use them, see the following articles:
# - [Relay Connection Documentation](https://facebook.github.io/relay/docs/en/graphql-server-specification.html#connections)
# - [Relay Connection Specification](https://facebook.github.io/relay/graphql/connections.htm)
# - [Using Relay-style Connections With Apollo Client](https://www.apollographql.com/docs/react/recipes/pagination.html)
type TaxRateConnection {
  # The list of nodes that match the query, wrapped in an edge to provide a cursor string for each
  edges: [TaxRateEdge]

  # You can request the `nodes` directly to avoid the extra wrapping that `NodeEdge` has,
  # if you know you will not need to paginate the results.
  nodes: [TaxRate]

  # Information to help a client request the next or previous page
  pageInfo: PageInfo!

  # The total number of nodes that match your query
  totalCount: Int!
}

# A connection edge in which each node is a `TaxRate` object
type TaxRateEdge {
  # The cursor that represents this node in the paginated results
  cursor: ConnectionCursor!

  # The tax rate
  node: TaxRate
}

# A single calculated tax for a cart, order group, cart item, or order item
type TaxRate {
  # Tax rate ID
  _id: ID!

  # An optional country code to limit where this tax is applied, in conjunction with `sourcing` field
  country: String

  # An optional postal code to limit where this tax is applied, in conjunction with `sourcing` field
  postal: String

  # The tax rate. For example, 0.05 for a 5% sales tax.
  rate: Float!

  # An optional region (e.g., state) to limit where this tax is applied, in conjunction with `sourcing` field
  region: String

  # The shop to which this TaxRate belongs
  shop: Shop!

  # Whether the `country`, `postal`, and `region` filters apply to the origin address or the destination address
  sourcing: TaxSource!

  # An optional tax code, to apply this tax rate to only products that have this tax code
  taxCode: String
}

# The fields by which you are allowed to sort any query that returns a `NavigationItemConnection`
enum NavigationItemSortByField {
  # Sort by NavigationItem ID
  _id

  # Sort by when the NavigationItem was created
  createdAt
}

# Wraps a list of `NavigationItem`s, providing pagination cursors and information.
#
# For information about what Relay-compatible connections are and how to use them, see the following articles:
# - [Relay Connection Documentation](https://facebook.github.io/relay/docs/en/graphql-server-specification.html#connections)
# - [Relay Connection Specification](https://facebook.github.io/relay/graphql/connections.htm)
# - [Using Relay-style Connections With Apollo Client](https://www.apollographql.com/docs/react/recipes/pagination.html)
type NavigationItemConnection {
  # The list of nodes that match the query, wrapped in an edge to provide a cursor string for each
  edges: [NavigationItemEdge]

  # You can request the `nodes` directly to avoid the extra wrapping that `NodeEdge` has,
  # if you know you will not need to paginate the results.
  nodes: [NavigationItem]

  # Information to help a client request the next or previous page
  pageInfo: PageInfo!

  # The total number of nodes that match your query
  totalCount: Int!
}

# A connection edge in which each node is a `NavigationItem` object
type NavigationItemEdge implements NodeEdge {
  # The cursor that represents this node in the paginated results
  cursor: ConnectionCursor!

  # The navigation item
  node: NavigationItem
}

# Generated sitemap XML for a single shop
type Sitemap {
  # Date created
  createdAt: Date!

  # The sitemap handle
  handle: String!

  # The shop ID
  shopId: String!

  # The Sitemap XML content
  xml: String!
}

# A date string, such as 2007-12-03, compliant with the `full-date` format outlined in section 5.6 of the RFC 3339 profile of the ISO 8601 standard for representation of dates and times using the Gregorian calendar.
scalar Date

type TwoFactorSecretKey {
  ascii: String
  base32: String
  hex: String
  qr_code_ascii: String
  qr_code_hex: String
  qr_code_base32: String
  google_auth_qr: String
  otpauth_url: String
}

type User {
  id: ID!
  emails: [EmailRecord!]
  username: String
}

# Mutations have side effects, such as mutating data or triggering a task
type Mutation {
  # A test mutation that returns whatever string you send it
  echo(
    # Any string
    str: String
  ): String

  # Archive a MediaRecord to hide it without deleting the backing file data
  archiveMediaRecord(
    # Mutation input
    input: ArchiveMediaRecordInput!
  ): ArchiveMediaRecordPayload!

  # Create the MediaRecord for file data after you upload it
  createMediaRecord(
    # Mutation input
    input: CreateMediaRecordInput!
  ): CreateMediaRecordPayload!

  # Delete a MediaRecord to delete both the record and the backing file data
  deleteMediaRecord(
    # Mutation input
    input: DeleteMediaRecordInput!
  ): DeleteMediaRecordPayload!

  # Update the priority metadata for a MediaRecord. Used for sorting product and variant media in the catalog.
  updateMediaRecordPriority(
    # Mutation input
    input: UpdateMediaRecordPriorityInput!
  ): UpdateMediaRecordPriorityPayload!

  # Create a new shop
  createShop(
    # Mutation input
    input: CreateShopInput!
  ): CreateShopPayload!

  # Given shop data, update the Shops collection with this data
  updateShop(
    # Mutation input
    input: UpdateShopInput!
  ): UpdateShopPayload!

  # Returns app settings that are not shop specific. Plugins extend the GlobalSettings type to support
  # whatever settings they need.
  updateGlobalSettings(
    # Mutation input
    input: UpdateGlobalSettingsInput!
  ): UpdateGlobalSettingsPayload!

  # Returns app settings for a specific shop. Plugins extend the ShopSettings type to support
  # whatever settings they need.
  updateShopSettings(
    # Mutation input
    input: UpdateShopSettingsInput!
  ): UpdateShopSettingsPayload!

  # Retry a failed or cancelled email job
  retryFailedEmail(
    # Mutation input
    input: RetryFailedEmailInput!
  ): RetryFailedEmailPayload!

  # Create an address validation rule
  createAddressValidationRule(
    # Mutation input
    input: CreateAddressValidationRuleInput!
  ): CreateAddressValidationRulePayload!

  # Delete an address validation rule
  deleteAddressValidationRule(
    # Mutation input
    input: DeleteAddressValidationRuleInput!
  ): DeleteAddressValidationRulePayload!

  # Update an address validation rule
  updateAddressValidationRule(
    # Mutation input
    input: UpdateAddressValidationRuleInput!
  ): UpdateAddressValidationRulePayload!

  # Use this mutation to verify the SMTP email settings
  verifySMTPEmailSettings(
    # Mutation input
    input: VerifySMTPEmailSettingsInput!
  ): VerifySMTPEmailSettingsInputPayload!

  # Updates an existing template
  updateTemplate(
    # Mutation input
    input: UpdateTemplateInput!
  ): UpdateTemplatePayload!

  # Add a new address to the `addressBook` field for an account
  addAccountAddressBookEntry(
    # Mutation input
    input: AddAccountAddressBookEntryInput!
  ): AddAccountAddressBookEntryPayload

  # Add an email address to an account
  addAccountEmailRecord(
    # Mutation input
    input: AddAccountEmailRecordInput!
  ): AddAccountEmailRecordPayload

  # Create an account based off a user
  createAccount(
    # Mutation input
    input: CreateAccountInput!
  ): CreateAccountPayload

  # Remove an address from the `addressBook` field for an account
  removeAccountAddressBookEntry(
    # Mutation input
    input: RemoveAccountAddressBookEntryInput!
  ): RemoveAccountAddressBookEntryPayload

  # Remove an email address from an account
  removeAccountEmailRecord(
    # Mutation input
    input: RemoveAccountEmailRecordInput!
  ): RemoveAccountEmailRecordPayload

  # Send a reset password email to an email address from an account
  sendResetAccountPasswordEmail(
    # Mutation input
    input: SendResetAccountPasswordEmailInput!
  ): SendResetAccountPasswordEmailPayload

  # Set default email address for an account
  setAccountDefaultEmail(
    # Mutation input
    input: SetAccountDefaultEmailInput!
  ): SetAccountDefaultEmailPayload

  # Remove an address that exists in the `addressBook` field for an account
  updateAccountAddressBookEntry(
    # Mutation input
    input: UpdateAccountAddressBookEntryInput!
  ): UpdateAccountAddressBookEntryPayload

  # Update account fields
  updateAccount(
    # Mutation input
    input: UpdateAccountInput!
  ): UpdateAccountPayload

  # Bulk-update groups for accounts
  updateGroupsForAccounts(
    # Mutation input
    input: UpdateGroupsForAccountsInput!
  ): UpdateGroupsForAccountsPayload

  # Grant admin UI access for shops to a specific users
  grantAdminUIAccess(
    input: GrantOrRevokeAdminUIAccessInput!
  ): GrantOrRevokeAdminUIAccessPayload!

  # Revoke admin UI access to shops for specific users
  revokeAdminUIAccess(
    input: GrantOrRevokeAdminUIAccessInput!
  ): GrantOrRevokeAdminUIAccessPayload!

  # Update admin UI access to shops for specific users
  updateAdminUIAccess(
    input: UpdateAdminUIAccessInput!
  ): UpdateAdminUIAccessPayload!

  # Add an account to a group
  addAccountToGroup(
    # Mutation input
    input: AddAccountToGroupInput!
  ): AddAccountToGroupPayload

  # Create a new account group. These are usually used for account permissions
  createAccountGroup(
    # Mutation input
    input: CreateAccountGroupInput!
  ): CreateAccountGroupPayload

  # Remove an account from a group
  removeAccountFromGroup(
    # Mutation input
    input: RemoveAccountFromGroupInput!
  ): RemoveAccountFromGroupPayload

  # Remove an existing account group
  removeAccountGroup(
    # Mutation input
    input: RemoveAccountGroupInput!
  ): RemoveAccountGroupPayload

  # Update an existing account group
  updateAccountGroup(
    # Mutation input
    input: UpdateAccountGroupInput!
  ): UpdateAccountGroupPayload

  # Given a person's email address and name, invite them to create an account for a certain shop,
  # and put them in the provided permission group
  inviteShopMember(
    # Mutation input
    input: InviteShopMemberInput!
  ): InviteShopMemberPayload

  # Archive products
  archiveProducts(
    # Mutation input
    input: ArchiveProductsInput!
  ): ArchiveProductsPayload!

  # Archive product variants
  archiveProductVariants(
    # Mutation input
    input: ArchiveProductVariantsInput!
  ): ArchiveProductVariantsPayload!

  # Update the isVisible property of an array of products
  updateProductsVisibility(
    # Mutation input
    input: UpdateProductsVisibilityInput!
  ): UpdateProductsVisibilityPayload!

  # Create a new product
  createProduct(
    # Mutation input
    input: CreateProductInput!
  ): CreateProductPayload!

  # Create a new product variant
  createProductVariant(
    # Mutation input
    input: CreateProductVariantInput!
  ): CreateProductVariantPayload!

  # Clone an existing product
  cloneProducts(
    # Mutation input
    input: CloneProductsInput!
  ): CloneProductsPayload!

  # Clone an existing product variant
  cloneProductVariants(
    # Mutation input
    input: CloneProductVariantsInput!
  ): CloneProductVariantsPayload!

  # Update an existing product
  updateProduct(
    # Mutation input
    input: UpdateProductInput!
  ): UpdateProductPayload!

  # Update an existing product variant
  updateProductVariant(
    # Mutation input
    input: UpdateProductVariantInput!
  ): UpdateProductVariantPayload!

  # Bulk operation for adding an array of tags to an array of products
  addTagsToProducts(
    # input which must includes an array of product ids and an array of tag ids
    input: ProductTagsOperationInput!
  ): ProductTagsOperationPayload!

  # Bulk operation for removing an array of tags from an array of products
  removeTagsFromProducts(
    # input which must includes an array of product ids and an array of tag ids
    input: ProductTagsOperationInput!
  ): ProductTagsOperationPayload!

  # Publish products to the Catalog collection by product ID
  publishProductsToCatalog(
    # Array of Product ID
    productIds: [ID]!
  ): [CatalogItemProduct]

  # Adds a new tag
  addTag(
    # Mutation input
    input: AddTagInput!
  ): AddTagPayload!

  # Removes an existing tag
  removeTag(
    # Mutation input
    input: RemoveTagInput!
  ): RemoveTagPayload!

  # Add an image to the tag
  setTagHeroMedia(
    # Mutation input
    input: SetTagHeroMediaInput!
  ): SetTagHeroMediaPayload!

  # Updates an existing tag
  updateTag(
    # Mutation input
    input: UpdateTagInput!
  ): UpdateTagPayload!

  # Update an existing product variants prices
  updateProductVariantPrices(
    # Mutation input
    input: UpdateProductVariantPricesInput!
  ): UpdateProductVariantPricesPayload!

  # Force recalculation of the system-managed `inventoryReserved` field based on current order statuses
  recalculateReservedSimpleInventory(
    # Mutation input
    input: RecalculateReservedSimpleInventoryInput!
  ): RecalculateReservedSimpleInventoryPayload!

  # Update the SimpleInventory info for a product configuration
  updateSimpleInventory(
    # Mutation input
    input: UpdateSimpleInventoryInput!
  ): UpdateSimpleInventoryPayload!

  # Add item(s) to a cart
  addCartItems(
    # Mutation input
    input: AddCartItemsInput!
  ): AddCartItemsPayload!

  # Create a new cart
  createCart(
    # Mutation input
    input: CreateCartInput!
  ): CreateCartPayload!

  # Reconcile an anonymous cart with the current account cart for the same shop
  reconcileCarts(
    # Mutation input
    input: ReconcileCartsInput!
  ): ReconcileCartsPayload!

  # Remove item(s) from a cart
  removeCartItems(
    # Mutation input
    input: RemoveCartItemsInput!
  ): RemoveCartItemsPayload!

  # Set the email address for an anonymous cart
  setEmailOnAnonymousCart(
    # Mutation input
    input: SetEmailOnAnonymousCartInput!
  ): SetEmailOnAnonymousCartPayload!

  # Update cart item(s) quantity. Use absolute quantity. If updating to 0, the item will be removed.
  updateCartItemsQuantity(
    # Mutation input
    input: UpdateCartItemsQuantityInput!
  ): UpdateCartItemsQuantityPayload!

  # Select a fulfillment option from the `availableFulfillmentOptions` list for a fulfillment group
  selectFulfillmentOptionForGroup(
    # Mutation input
    input: SelectFulfillmentOptionForGroupInput!
  ): SelectFulfillmentOptionForGroupPayload!

  # Set the shipping address for all fulfillment groups
  setShippingAddressOnCart(
    # Mutation input
    input: SetShippingAddressOnCartInput!
  ): SetShippingAddressOnCartPayload!

  # Clients should call this as necessary during checkout to update the `availableFulfillmentOptions`
  # property for all fulfillment groups of the cart with fresh price quotes. These need to be
  # recalculated every time the items in that group change. When the order is placed, the chosen
  # option for each group will have its prices recalculated one last time. If the prices do not match,
  # order creation will fail.
  updateFulfillmentOptionsForGroup(
    # Mutation input
    input: UpdateFulfillmentOptionsForGroupInput!
  ): UpdateFulfillmentOptionsForGroupPayload!

  # Use this mutation to add a new order fulfillment group to an order. It must have at least one
  # item. Items may be provided or moved from another existing group or both.
  addOrderFulfillmentGroup(
    # Mutation input
    input: AddOrderFulfillmentGroupInput!
  ): AddOrderFulfillmentGroupPayload!

  # Use this mutation to cancel one item of an order, either for the full ordered quantity
  # or for a partial quantity. If partial, the item will be split into two items and the
  # original item will have a lower quantity and will be canceled.
  #
  # If this results in all items in a fulfillment group being canceled, the group will also
  # be canceled. If this results in all fulfillment groups being canceled, the full order will
  # also be canceled.
  cancelOrderItem(
    # Mutation input
    input: CancelOrderItemInput!
  ): CancelOrderItemPayload!

  # Use this mutation to create a refund on a payment method used to make the order
  createRefund(
    # Mutation input
    input: CreateRefundInput!
  ): CreateRefundPayload!

  # Use this mutation to move one or more items between existing order fulfillment groups.
  moveOrderItems(
    # Mutation input
    input: MoveOrderItemsInput!
  ): MoveOrderItemsPayload!

  # Use this mutation to place an order, providing information necessary to pay for it.
  # The order will be placed only if authorization is successful for all submitted payments.
  placeOrder(
    # Mutation input
    input: PlaceOrderInput!
  ): PlaceOrderPayload!

  # Use this mutation to reduce the quantity of one item of an order and create
  # a new item for the remaining quantity in the same fulfillment group, and with the
  # same item status. You may want to do this if you are only able to partially fulfill
  # the item order right now.
  splitOrderItem(
    # Mutation input
    input: SplitOrderItemInput!
  ): SplitOrderItemPayload!

  # Use this mutation to update order details after the order has been placed.
  updateOrder(
    # Mutation input
    input: UpdateOrderInput!
  ): UpdateOrderPayload!

  # Use this mutation to update an order fulfillment group status and tracking information.
  updateOrderFulfillmentGroup(
    # Mutation input
    input: UpdateOrderFulfillmentGroupInput!
  ): UpdateOrderFulfillmentGroupPayload!

  # Approve one or more payments for an order
  approveOrderPayments(
    # Mutation input
    input: ApproveOrderPaymentsInput!
  ): ApproveOrderPaymentsPayload!

  # Capture one or more payments for an order
  captureOrderPayments(
    # Mutation input
    input: CaptureOrderPaymentsInput!
  ): CaptureOrderPaymentsPayload!

  # Enable a payment method for a shop
  enablePaymentMethodForShop(
    # Mutation input
    input: EnablePaymentMethodForShopInput!
  ): EnablePaymentMethodForShopPayload!

  # Create Stripe payment intent for the current cart and return a token
  createStripePaymentIntent(
    input: CreateStripePaymentIntentInput!
  ): CreateStripePaymentIntentPayload!

  # Create a new discount code
  createDiscountCode(
    # Mutation input
    input: CreateDiscountCodeInput!
  ): CreateDiscountCodePayload

  # Update a discount code
  updateDiscountCode(
    # Mutation input
    input: UpdateDiscountCodeInput!
  ): UpdateDiscountCodePayload

  # Delete a discount code
  deleteDiscountCode(
    # Mutation input
    input: DeleteDiscountCodeInput!
  ): DeleteDiscountCodePayload

  # Apply a discount code to a cart
  applyDiscountCodeToCart(
    # Mutation input
    input: ApplyDiscountCodeToCartInput!
  ): ApplyDiscountCodeToCartPayload!

  # Remove a discount code from a cart
  removeDiscountCodeFromCart(
    # Mutation input
    input: RemoveDiscountCodeFromCartInput!
  ): RemoveDiscountCodeFromCartPayload!

  # Create a surcharge
  createSurcharge(
    # Mutation input
    input: CreateSurchargeInput!
  ): CreateSurchargePayload!

  # Delete a flat rate fulfillment restriction
  deleteSurcharge(
    # Mutation input
    input: DeleteSurchargeInput!
  ): DeleteSurchargePayload!

  # Update a flat rate fulfillment surcharge
  updateSurcharge(
    # Mutation input
    input: UpdateSurchargeInput!
  ): UpdateSurchargePayload!

  # Create a flat rate fulfillment method
  createFlatRateFulfillmentMethod(
    # Mutation input
    input: CreateFlatRateFulfillmentMethodInput!
  ): CreateFlatRateFulfillmentMethodPayload!

  # Update a flat rate fulfillment method
  updateFlatRateFulfillmentMethod(
    # Mutation input
    input: UpdateFlatRateFulfillmentMethodInput!
  ): UpdateFlatRateFulfillmentMethodPayload!

  # Delete a flat rate fulfillment method
  deleteFlatRateFulfillmentMethod(
    # Mutation input
    input: DeleteFlatRateFulfillmentMethodInput!
  ): DeleteFlatRateFulfillmentMethodPayload!

  # Create a flat rate fulfillment method restriction.
  createFlatRateFulfillmentRestriction(
    # Mutation input
    input: CreateFlatRateFulfillmentRestrictionInput!
  ): CreateFlatRateFulfillmentRestrictionPayload!

  # Delete a flat rate fulfillment method restriction
  deleteFlatRateFulfillmentRestriction(
    # Mutation input
    input: DeleteFlatRateFulfillmentRestrictionInput!
  ): DeleteFlatRateFulfillmentRestrictionPayload!

  # Update a flat rate fulfillment method restriction
  updateFlatRateFulfillmentRestriction(
    # Mutation input
    input: UpdateFlatRateFulfillmentRestrictionInput!
  ): UpdateFlatRateFulfillmentRestrictionPayload!

  # Create a new tax rate
  createTaxRate(
    # Mutation input
    input: CreateTaxRateInput!
  ): CreateTaxRatePayload

  # Update a tax rate
  updateTaxRate(
    # Mutation input
    input: UpdateTaxRateInput!
  ): UpdateTaxRatePayload

  # Delete a tax rate
  deleteTaxRate(
    # Mutation input
    input: DeleteTaxRateInput!
  ): DeleteTaxRatePayload

  # Create a new navigation item
  createNavigationItem(
    # Mutation input
    input: CreateNavigationItemInput!
  ): CreateNavigationItemPayload

  # Create a new navigation tree
  createNavigationTree(
    # Mutation input
    input: CreateNavigationTreeInput!
  ): CreateNavigationTreePayload!

  # Delete a navigation item
  deleteNavigationItem(
    # Mutation input
    input: DeleteNavigationItemInput!
  ): DeleteNavigationItemPayload

  # Publish the draft structure for a navigation tree and the draft changes for all of its navigation items. Sets hasUnpublishedChanges to false on tree and its items
  publishNavigationChanges(
    # Mutation input
    input: PublishNavigationChangesInput!
  ): PublishNavigationChangesPayload

  # Update an existing navigation item's draft data. Sets hasUnpublishedChanges to true
  updateNavigationItem(
    # Mutation input
    input: UpdateNavigationItemInput!
  ): UpdateNavigationItemPayload

  # Update an existing navigation tree's draft items. Sets hasUnpublishedChanges to true
  updateNavigationTree(
    # Mutation input
    input: UpdateNavigationTreeInput!
  ): UpdateNavigationTreePayload

  # Generate sitemap documents
  generateSitemaps(
    # Mutation input
    input: GenerateSitemapsInput
  ): GenerateSitemapsPayload!
  createUser(user: CreateUserInput!): CreateUserResult
  verifyEmail(token: String!): Boolean
  resetPassword(token: String!, newPassword: String!): LoginResult
  sendVerificationEmail(email: String!): Boolean
  sendResetPasswordEmail(email: String!): Boolean
  addEmail(newEmail: String!): Boolean
  changePassword(oldPassword: String!, newPassword: String!): Boolean
  twoFactorSet(secret: TwoFactorSecretKeyInput!, code: String!): Boolean
  twoFactorUnset(code: String!): Boolean
  impersonate(
    accessToken: String!
    impersonated: ImpersonationUserIdentityInput!
  ): ImpersonateReturn
  refreshTokens(accessToken: String!, refreshToken: String!): LoginResult
  logout: Boolean
  authenticate(
    serviceName: String!
    params: AuthenticateParamsInput!
  ): LoginResult
  verifyAuthentication(
    serviceName: String!
    params: AuthenticateParamsInput!
  ): Boolean
}

# Input for the archiveMediaRecord mutation
input ArchiveMediaRecordInput {
  # An optional string identifying the mutation call, which will be returned in the response payload
  clientMutationId: String

  # ID of MediaRecord to archive
  mediaRecordId: ID!

  # ID of shop that owns this MediaRecord
  shopId: ID!
}

# Response payload for the archiveMediaRecord mutation
type ArchiveMediaRecordPayload {
  # The same string you sent with the mutation params, for matching mutation calls with their responses
  clientMutationId: String

  # The archived MediaRecord
  mediaRecord: MediaRecord!
}

# A FileRecord for a media file
type MediaRecord {
  # MediaRecord ID
  _id: ID!

  # Custom metadata for the media record
  metadata: MediaRecordMetadata!

  # Core info about the original uploaded file
  original: MediaRecordInfo!
}

# Custom metadata for the media record
type MediaRecordMetadata {
  # True if the MediaRecord is archived. This typically means that the media will not show in a storefront but the image file data still exists.
  isArchived: Boolean!

  # ID of the account that uploaded the file
  ownerId: String

  # Priority among media files with similar metadata
  priority: Int

  # ID of the related product, if the media is for a product
  productId: String

  # ID of the shop that owns the media
  shopId: String!

  # A string that identifies where this media will be used, for filtering
  type: String

  # ID of the related product variant, if the media is for a product variant
  variantId: String
}

# Core info about the original uploaded media file
type MediaRecordInfo {
  # File name
  name: String!

  # File size
  size: Int!

  # File type
  type: String!

  # Date and time at which the file was last updated
  updatedAt: DateTime!

  # Date and time at which the file was uploaded
  uploadedAt: DateTime!
}

# Input for the createMediaRecord mutation
input CreateMediaRecordInput {
  # An optional string identifying the mutation call, which will be returned in the response payload
  clientMutationId: String

  # The media record to insert, with related file data already fully uploaded to temporary storage
  mediaRecord: MediaRecordInput!

  # ID of shop that owns this MediaRecord
  shopId: ID!
}

# A FileRecord for a media file
input MediaRecordInput {
  # Custom metadata for the media record
  metadata: MediaRecordMetadataInput!

  # Core info about the original uploaded file
  original: MediaRecordInfoInput!
}

# Custom metadata for the media record
input MediaRecordMetadataInput {
  # Priority among media files with similar metadata
  priority: Int

  # ID of the related product, if the media is for a product
  productId: ID

  # A string that identifies where this media will be used, for filtering
  type: String

  # ID of the related product variant, if the media is for a product variant
  variantId: ID
}

# Core info about the original uploaded media file
input MediaRecordInfoInput {
  # File name
  name: String!

  # File size
  size: Int!

  # ID of the file uploaded to temporary storage
  tempStoreId: String!

  # File type
  type: String!

  # Date and time at which the file was last updated
  updatedAt: DateTime!

  # Date and time at which the file was uploaded
  uploadedAt: DateTime!
}

# Response payload for the createMediaRecord mutation
type CreateMediaRecordPayload {
  # The same string you sent with the mutation params, for matching mutation calls with their responses
  clientMutationId: String

  # The created MediaRecord
  mediaRecord: MediaRecord!
}

# Input for the deleteMediaRecord mutation
input DeleteMediaRecordInput {
  # An optional string identifying the mutation call, which will be returned in the response payload
  clientMutationId: String

  # ID of MediaRecord to delete
  mediaRecordId: ID!

  # ID of shop that owns this MediaRecord
  shopId: ID!
}

# Response payload for the deleteMediaRecord mutation
type DeleteMediaRecordPayload {
  # The same string you sent with the mutation params, for matching mutation calls with their responses
  clientMutationId: String

  # The deleted MediaRecord
  mediaRecord: MediaRecord!
}

# Input for the updateMediaRecordPriority mutation
input UpdateMediaRecordPriorityInput {
  # An optional string identifying the mutation call, which will be returned in the response payload
  clientMutationId: String

  # ID of MediaRecord to update
  mediaRecordId: ID!

  # New priority value
  priority: Int!

  # ID of shop that owns this MediaRecord
  shopId: ID!
}

# Response payload for the updateMediaRecordPriority mutation
type UpdateMediaRecordPriorityPayload {
  # The same string you sent with the mutation params, for matching mutation calls with their responses
  clientMutationId: String

  # The updated MediaRecord
  mediaRecord: MediaRecord!
}

# Input parameters for the `createShop` mutation
input CreateShopInput {
  # An optional string identifying the mutation call, which will be returned in the response payload
  clientMutationId: String

  # Currency in which all money values should be assumed to be. Default is `USD`.
  currencyCode: String

  # Default language for translation and localization. Default is `en`.
  defaultLanguage: String

  # Primary timezone. Default is `US/Pacific`
  defaultTimezone: String

  # An optional description of the shop, intended for only admins to see
  description: String

  # A unique name for the shop
  name: String!

  # The shop type. Default is `primary`, but there may be only one primary shop.
  type: String
}

# The response from the `createShop` mutation
type CreateShopPayload {
  # The same string you sent with the mutation params, for matching mutation calls with their responses
  clientMutationId: String

  # The shop which was created
  shop: Shop!
}

# Input parameters for the updateShop mutation
input UpdateShopInput {
  # An address book entry to set the primary shop's address
  addressBook: [AddressInput]

  # Whether to allow user to checkout without creating an account
  allowGuestCheckout: Boolean

  # The base unit of length
  baseUOL: String

  # The base unit of Measure
  baseUOM: String

  # ID of media record to be used as the brand asset
  brandAssets: ID

  # An optional string identifying the mutation call, which will be returned in the response payload
  clientMutationId: String

  # The shop's currency
  currency: String

  # Default parcel size used for this shop
  defaultParcelSize: ShopParcelSizeInput

  # The shop's description
  description: String

  # The shops primary email address
  emails: [EmailRecordInput]

  # The shop's keywords
  keywords: String

  # The shop's language
  language: String

  # The shop's name
  name: String

  # The ID of the shop to update
  shopId: ID!

  # Object of shop logo urls
  shopLogoUrls: ShopLogoUrlsInput

  # Shop's slug
  slug: String

  # Object of storefront routes urls
  storefrontUrls: StorefrontUrlsInput

  # The shop's timezone
  timezone: String
}

# Parcel size input
input ShopParcelSizeInput {
  # Parcel height
  height: Float

  # Parcel length
  length: Float

  # Parcel weight
  weight: Float

  # Parcel width
  width: Float
}

# A confirmable email record
input EmailRecordInput {
  # The actual email address
  address: String

  # The services provided by this address
  provides: String

  # Has this address been verified?
  verified: Boolean
}

# Shop Logo URLs to provide for the updateShop mutation
input ShopLogoUrlsInput {
  # The primary logo URL for this shop. Setting this overrides any uploaded logo.
  primaryShopLogoUrl: String
}

# Storefront route URLs to provide for the updateShop mutation
input StorefrontUrlsInput {
  # Storefront Account Profile URL (can include `:accountId` in string)
  storefrontAccountProfileUrl: String

  # Storefront Home URL
  storefrontHomeUrl: String

  # Storefront login URL
  storefrontLoginUrl: String

  # Storefront single order URL (can include `:orderReferenceId` and `:orderToken` in string)
  storefrontOrderUrl: String

  # Storefront orders URL (can include `:accountId` in string)
  storefrontOrdersUrl: String
}

# The response from the `updateShop` mutation
type UpdateShopPayload {
  # The same string you sent with the mutation params, for matching mutation calls with their responses
  clientMutationId: String

  # The shop which was updated
  shop: Shop!
}

# Input for the `updateGlobalSettings` mutation
input UpdateGlobalSettingsInput {
  # An optional string identifying the mutation call, which will be returned in the response payload
  clientMutationId: String

  # Updated settings values. Only includes settings to be changed.
  settingsUpdates: GlobalSettingsUpdates!
}

# Updates for app settings that are not shop specific. Plugins extend
# this input type to support whatever settings they need. All fields
# must be optional.
input GlobalSettingsUpdates {
  # Do not use this field
  doNotUse: String
}

# Response payload for the `updateGlobalSettings` mutation
type UpdateGlobalSettingsPayload {
  # The same string you sent with the mutation params, for matching mutation calls with their responses
  clientMutationId: String

  # Updated global settings
  globalSettings: GlobalSettings!
}

# Input for the `updateShopSettings` mutation
input UpdateShopSettingsInput {
  # An optional string identifying the mutation call, which will be returned in the response payload
  clientMutationId: String

  # Updated settings values. Only includes settings to be changed.
  settingsUpdates: ShopSettingsUpdates!

  # The ID of the shop to update some settings for
  shopId: ID!
}

# Updates for app settings that are not shop specific. Plugins extend
# this input type to support whatever settings they need. All fields
# must be optional.
input ShopSettingsUpdates {
  # Do not use this field
  doNotUse: String

  # If there is no known inventory for a product configuration, this setting determines
  # whether that product configuration can be sold and should appear to be available.
  canSellVariantWithoutInventory: Boolean

  # Set to `false` to prevent any defined shipping rates from being used when fulfillment
  # quotes are requested for a cart or order. A quick way to disable the entire
  # `reaction-shipping-rates` plugin temporarily.
  isShippingRatesFulfillmentEnabled: Boolean

  # The default value to use for `taxCode` property of a product
  defaultTaxCode: String

  # Optionally, set the name of the tax service to fall back to if the primary tax service is down.
  # This must match the `name` field of one of the services returned by the `taxServices` query.
  fallbackTaxServiceName: String

  # Set the name of the tax service to use for calculating taxes on carts and orders.
  # This will match the `name` field of one of the services returned by the `taxServices`
  # query. There will be no taxes charged for any carts or orders if this is not set.
  primaryTaxServiceName: String

  # Whether a navigation item added to the navigation tree should be visible only to
  # admins by default.
  shouldNavigationTreeItemsBeAdminOnly: Boolean

  # Whether a navigation item added to the navigation tree should be
  # public API/Storefront visible by default.
  shouldNavigationTreeItemsBePubliclyVisible: Boolean

  # Whether a navigation item added to the navigation tree should be a secondary
  # navigation item by default.
  shouldNavigationTreeItemsBeSecondaryNavOnly: Boolean

  # This setting controls how often the sitemaps for the shop will be rebuilt
  sitemapRefreshPeriod: String
}

# Response payload for the `updateShopSettings` mutation
type UpdateShopSettingsPayload {
  # The same string you sent with the mutation params, for matching mutation calls with their responses
  clientMutationId: String

  # Updated shop settings
  shopSettings: ShopSettings!
}

# Input for `retryFailedEmail` mutation
input RetryFailedEmailInput {
  # An optional string identifying the mutation call, which will be returned in the response payload
  clientMutationId: String

  # ID of Email Job to retry
  jobId: ID!

  # Shop ID of Email Job
  shopId: ID!
}

# Response payload for `retryFailedEmail` mutation
type RetryFailedEmailPayload {
  # The same string you sent with the mutation params, for matching mutation calls with their responses
  clientMutationId: String

  # Email retry status
  emailSent: Boolean!
}

# Input for the `createAddressValidationRule` mutation
input CreateAddressValidationRuleInput {
  # An optional string identifying the mutation call, which will be returned in the response payload
  clientMutationId: String

  # Country codes for which this service is enabled. `null` means all, while an empty array means none.
  countryCodes: [String]

  # The name of one of the installed validation services. Use `addressValidationServices`
  # query to get a list, and then use the `name` field value from one of them.
  serviceName: String!

  # ID of the shop to which this rule applies
  shopId: ID!
}

# Payload for the `createAddressValidationRule` mutation
type CreateAddressValidationRulePayload {
  # Created address validation rule
  addressValidationRule: AddressValidationRule!

  # The same string you sent with the mutation params, for matching mutation calls with their responses
  clientMutationId: String
}

# Input for the `deleteAddressValidationRule` mutation
input DeleteAddressValidationRuleInput {
  # An optional string identifying the mutation call, which will be returned in the response payload
  clientMutationId: String

  # ID of the rule you want to delete
  ruleId: ID!

  # Shop ID of the rule you want to delete
  shopId: ID!
}

# Payload for the `deleteAddressValidationRule` mutation
type DeleteAddressValidationRulePayload {
  # Deleted address validation rule
  addressValidationRule: AddressValidationRule!

  # The same string you sent with the mutation params, for matching mutation calls with their responses
  clientMutationId: String
}

# Input for the `updateAddressValidationRule` mutation
input UpdateAddressValidationRuleInput {
  # An optional string identifying the mutation call, which will be returned in the response payload
  clientMutationId: String

  # Country codes for which this service is enabled. `null` means all, while an empty array means none.
  countryCodes: [String]

  # ID of the rule you want to update
  ruleId: ID!

  # The name of one of the installed validation services. Use `addressValidationServices`
  # query to get a list, and then use the `name` field value from one of them.
  serviceName: String!

  # Shop ID of the rule you want to update. This is not something you can modify.
  shopId: ID!
}

# Payload for the `updateAddressValidationRule` mutation
type UpdateAddressValidationRulePayload {
  # Updated address validation rule
  addressValidationRule: AddressValidationRule!

  # The same string you sent with the mutation params, for matching mutation calls with their responses
  clientMutationId: String
}

# Input for an `VerifySMTPEmailSettingsInput`
input VerifySMTPEmailSettingsInput {
  # The ID of the shop this setting belongs to
  shopId: ID!
}

# Response payload for the verifySMTPEmailSettings mutation
type VerifySMTPEmailSettingsInputPayload {
  # The same string you sent with the mutation params, for matching mutation calls with their responses
  clientMutationId: String

  # True if the SMTP connection was made and authentication was successful.
  isVerified: Boolean!
}

# Input for `updateTemplate` mutation
input UpdateTemplateInput {
  # An optional string identifying the mutation call, which will be returned in the response payload
  clientMutationId: String

  # ID of template to modify
  id: ID!

  # The shop that owns the template
  shopId: ID!

  # Email template string
  subject: String

  # Email template body or html text
  template: String

  # Email template title
  title: String
}

# Response payload for `updateTemplate` mutation
type UpdateTemplatePayload {
  # The same string you sent with the mutation params, for matching mutation calls with their responses
  clientMutationId: String

  # The updated template
  template: Template!
}

# Defines a new Address and the account to which it should be added
input AddAccountAddressBookEntryInput {
  # The account ID
  accountId: ID!

  # The address to add
  address: AddressInput!

  # An optional string identifying the mutation call, which will be returned in the response payload
  clientMutationId: String
}

# The response from the `addAccountAddressBookEntry` mutation
type AddAccountAddressBookEntryPayload {
  # The added address
  address: Address

  # The added address edge
  addressEdge: AddressEdge

  # The same string you sent with the mutation params, for matching mutation calls with their responses
  clientMutationId: String
}

# Defines a new Email and the account to which it should be added
input AddAccountEmailRecordInput {
  # The account ID, which defaults to the viewer account
  accountId: ID

  # An optional string identifying the mutation call, which will be returned in the response payload
  clientMutationId: String

  # The email address to add
  email: Email!
}

# The response from the `addAccountEmailRecord` mutation
type AddAccountEmailRecordPayload {
  # The account, with updated `emailRecords`
  account: Account

  # The same string you sent with the mutation params, for matching mutation calls with their responses
  clientMutationId: String
}

# Defines the account which should be created
input CreateAccountInput {
  # Bio to display on profile
  bio: String

  # Email record to create account with
  emails: [EmailRecordInput]!

  # Name to display on profile
  name: String

  # URL of picture to display on profile
  picture: String

  # The ID of the shop this account will belong to
  shopId: ID!

  # The userID account was created from create a new account from
  userId: ID!

  # Username
  username: String
}

# The response from the `createAccount` mutation
type CreateAccountPayload {
  # The added account
  account: Account

  # The same string you sent with the mutation params, for matching mutation calls with their responses
  clientMutationId: String
}

# Describes which address should be removed from which account
input RemoveAccountAddressBookEntryInput {
  # The account ID
  accountId: ID!

  # The address ID
  addressId: ID!

  # An optional string identifying the mutation call, which will be returned in the response payload
  clientMutationId: String
}

# The response from the `removeAccountAddressBookEntry` mutation
type RemoveAccountAddressBookEntryPayload {
  # The removed address
  address: Address

  # The same string you sent with the mutation params, for matching mutation calls with their responses
  clientMutationId: String
}

# Defines which email address should be removed from which account
input RemoveAccountEmailRecordInput {
  # The account ID, which defaults to the viewer account
  accountId: ID

  # An optional string identifying the mutation call, which will be returned in the response payload
  clientMutationId: String

  # The email address to remove
  email: Email!
}

# The response from the `removeAccountEmailRecord` mutation
type RemoveAccountEmailRecordPayload {
  # The account, with updated `emailRecords`
  account: Account

  # The same string you sent with the mutation params, for matching mutation calls with their responses
  clientMutationId: String
}

# Describes which email should be sent a password reset link
input SendResetAccountPasswordEmailInput {
  # An optional string identifying the mutation call, which will be returned in the response payload
  clientMutationId: String

  # The email address of the account to send reset email to
  email: String!
}

# The response from the `sendResetAccountPasswordEmail` mutation
type SendResetAccountPasswordEmailPayload {
  # The same string you sent with the mutation params, for matching mutation calls with their responses
  clientMutationId: String

  # The email address of the account to send reset email to
  email: String!
}

# Defines which email address should be set as the default for which account
input SetAccountDefaultEmailInput {
  # The account ID, which defaults to the viewer account
  accountId: ID

  # An optional string identifying the mutation call, which will be returned in the response payload
  clientMutationId: String

  # The email address to set as default
  email: Email!
}

# The response from the `setAccountDefaultEmail` mutation
type SetAccountDefaultEmailPayload {
  # The account, with updated `emailRecords`
  account: Account

  # The same string you sent with the mutation params, for matching mutation calls with their responses
  clientMutationId: String
}

# Describes changes that should be applied to one of the addresses for an account
input UpdateAccountAddressBookEntryInput {
  # The account ID
  accountId: ID!

  # The address ID
  addressId: ID!

  # An optional string identifying the mutation call, which will be returned in the response payload
  clientMutationId: String

  # If present, make this address the default address of this type
  type: AddressType

  # The address changes to apply
  updates: AddressInput!
}

# A list of the possible types of `Address`
enum AddressType {
  # Address can be used for payment transactions and invoicing
  billing

  # Address can be used as a mailing address for sending physical items
  shipping
}

# The response from the `updateAccountAddressBookEntry` mutation
type UpdateAccountAddressBookEntryPayload {
  # The updated address
  address: Address

  # The same string you sent with the mutation params, for matching mutation calls with their responses
  clientMutationId: String
}

# Describes an account update
input UpdateAccountInput {
  # The account ID, which defaults to the viewer account
  accountId: ID

  # Bio to display on profile
  bio: String

  # An optional string identifying the mutation call, which will be returned in the response payload
  clientMutationId: String

  # The preferred currency code used by this account
  currencyCode: String

  # The first name of the person this account represents
  firstName: String

  # The preferred language (code) used by this account
  language: String

  # The last name of the person this account represents
  lastName: String

  # The full name of the person this account represents
  name: String

  # Some note about this account
  note: String

  # URL of picture to display on profile
  picture: String

  # Username
  username: String
}

# The response from the `updateAccount` mutation
type UpdateAccountPayload {
  # The updated account
  account: Account!

  # The same string you sent with the mutation params, for matching mutation calls with their responses
  clientMutationId: String
}

#
input UpdateGroupsForAccountsInput {
  # The account IDs
  accountIds: [ID]!

  # An optional string identifying the mutation call, which will be returned in the response payload
  clientMutationId: String

  # The group IDs
  groupIds: [ID]!
}

#
type UpdateGroupsForAccountsPayload {
  # The same string you sent with the mutation params, for matching mutation calls with their responses
  clientMutationId: String

  # The accounts that were modified
  accounts: [Account]!
}

#
input GrantOrRevokeAdminUIAccessInput {
  # An optional string identifying the mutation call, which will be returned in the response payload
  clientMutationId: String

  # The account ID to update
  accountId: String!

  # The shop IDs to unassign or assign to the accounts
  shopId: String!
}

#
type GrantOrRevokeAdminUIAccessPayload {
  # An optional string identifying the mutation call, which will be returned in the response payload
  clientMutationId: String

  # The up to date account object
  account: Account
}

#
input UpdateAdminUIAccessInput {
  # An optional string identifying the mutation call, which will be returned in the response payload
  clientMutationId: String

  # The account IDs to update
  accountIds: [String]!

  # The shop IDs to unassign or assign to the accounts
  shopIds: [String]!
}

#
type UpdateAdminUIAccessPayload {
  # An optional string identifying the mutation call, which will be returned in the response payload
  clientMutationId: String

  # The up to date account objects
  accounts: [Account]
}

# Defines a group and account that should be linked
input AddAccountToGroupInput {
  # The account ID
  accountId: ID!

  # An optional string identifying the mutation call, which will be returned in the response payload
  clientMutationId: String

  # The group ID
  groupId: ID!
}

# The response from the `addAccountToGroup` mutation
type AddAccountToGroupPayload {
  # The same string you sent with the mutation params, for matching mutation calls with their responses
  clientMutationId: String

  # The updated group
  group: Group
}

# The details for creating a group
input CreateAccountGroupInput {
  # An optional string identifying the mutation call, which will be returned in the response payload
  clientMutationId: String

  # The group to create
  group: GroupInput!

  # The ID of the shop this group belongs to
  shopId: ID
}

# A group definition
input GroupInput {
  # A free text description of this group
  description: String

  # A unique name for the group
  name: String!

  # A unique URL-safe string representing this group
  slug: String

  # A list of the account permissions implied by membership in this group
  permissions: [String]
}

# The response from the `createAccountGroup` mutation
type CreateAccountGroupPayload {
  # The same string you sent with the mutation params, for matching mutation calls with their responses
  clientMutationId: String

  # The new group
  group: Group
}

# Defines a group and account that should be unlinked
input RemoveAccountFromGroupInput {
  # The account ID
  accountId: ID!

  # An optional string identifying the mutation call, which will be returned in the response payload
  clientMutationId: String

  # The group ID
  groupId: ID!
}

# The response from the `removeAccountFromGroup` mutation
type RemoveAccountFromGroupPayload {
  # The same string you sent with the mutation params, for matching mutation calls with their responses
  clientMutationId: String

  # The removed group
  group: Group!
}

# The details for removing a group
input RemoveAccountGroupInput {
  # An optional string identifying the mutation call, which will be returned in the response payload
  clientMutationId: String

  # The group ID
  groupId: ID!

  # The ID of the shop this group belongs to
  shopId: ID
}

# The response from the `removeGroup` mutation
type RemoveAccountGroupPayload {
  # The same string you sent with the mutation params, for matching mutation calls with their responses
  clientMutationId: String

  # The removed group
  group: Group
}

# The details for updating a group
input UpdateAccountGroupInput {
  # An optional string identifying the mutation call, which will be returned in the response payload
  clientMutationId: String

  # The changes to apply to the group
  group: UpdateGroupInput!

  # The group ID
  groupId: ID!

  # The ID of the shop this group belongs to
  shopId: ID
}

# Fields to update for an existing account group
input UpdateGroupInput {
  # A free text description of this group
  description: String

  # A unique name for the group
  name: String

  # A unique URL-safe string representing this group
  slug: String

  # A list of the account permissions implied by membership in this group
  permissions: [String]
}

# The response from the `updateAccountGroup` mutation
type UpdateAccountGroupPayload {
  # The same string you sent with the mutation params, for matching mutation calls with their responses
  clientMutationId: String

  # The updated group
  group: Group
}

# Input parameters for the inviteShopMember mutation
input InviteShopMemberInput {
  # An optional string identifying the mutation call, which will be returned in the response payload
  clientMutationId: String

  # The email address of the person to invite
  email: String!

  # The permission group for this person's new account. DEPRECATED. Use `groupIds` field instead.
  groupId: ID

  # The permission groups for this person's new account
  groupIds: [ID]

  # The invitee's full name
  name: String!

  # The ID of the shop to which you want to invite this person
  shopId: ID!

  # Whether the newly invited user should get admin UI access to the shop upon sign-up
  shouldGetAdminUIAccess: Boolean
}

# The response from the `inviteShopMember` mutation
type InviteShopMemberPayload {
  # The account that was successfully created or found and updated by inviting this shop member
  account: Account

  # The same string you sent with the mutation params, for matching mutation calls with their responses
  clientMutationId: String
}

# Input for the `archiveProducts` mutation
input ArchiveProductsInput {
  # Array of IDs of products to archive
  productIds: [ID]!

  # ID of shop that owns all products you are archiving
  shopId: ID!
}

# Response payload of `archiveProducts` mutation
type ArchiveProductsPayload {
  # The same string you sent with the mutation params, for matching mutation calls with their responses
  clientMutationId: String

  # Array of newly archived products
  products: [Product]!
}

# Input for the `archiveProducts` mutation
input ArchiveProductVariantsInput {
  # ID of shop that owns all variants you are archiving
  shopId: ID!

  # Array of IDs of variants to archive
  variantIds: [ID]!
}

# Response payload of `archiveProductVariants` mutation
type ArchiveProductVariantsPayload {
  # The same string you sent with the mutation params, for matching mutation calls with their responses
  clientMutationId: String

  # Array of newly archived variants
  variants: [ProductVariant]!
}

# Input for the `updateProductsVisibility` mutation
input UpdateProductsVisibilityInput {
  # The desired visibility
  isVisible: Boolean!

  # Array of product ids to update
  productIds: [ID]!

  # ID of shop the products belong to
  shopId: ID!
}

# Response payload for `updateProductsVisibility` mutation
type UpdateProductsVisibilityPayload {
  # The same string you sent with the mutation params, for matching mutation calls with their responses
  clientMutationId: String

  # The number of products that were updated successfully
  updatedCount: Int
}

# Input for the `createProduct` mutation
input CreateProductInput {
  # Product input
  product: ProductInput

  # ID of shop product will belong to
  shopId: ID!

  # Set to false if you do not want to auto-create the first variant of the product
  shouldCreateFirstVariant: Boolean = true
}

# Mutation input for a product
input ProductInput {
  # Any string to use as the internal ID for a new product. Do not prefix or base64 encode this ID.
  # This field is allowed only when creating a product. If you include an ID for an update, you
  # will get an error. The string must also be different from any existing product, variant, or
  # option internal ID or you will get a duplicate ID error. If you do not include this when creating
  # a product, a random unique string is generated for you.
  _id: String

  # The full product description, which may have newline characters in it
  description: String

  # Facebook message
  facebookMsg: String

  # Google message
  googleplusMsg: String

  # True if this product has been deleted. Typically, deleted products are not returned in queries.
  isDeleted: Boolean

  # True if this product should be shown to shoppers. Typically, non-visible products are not returned in queries.
  isVisible: Boolean

  # The product description to use for page `description` meta element in HTML
  metaDescription: String

  # Arbitrary additional metadata about this product
  metafields: [MetafieldInput]

  # The country of origin
  originCountry: String

  # Subtitle
  pageTitle: String

  # Pinterest message
  pinterestMsg: String

  # An arbitrary product type value, such as from an external system
  productType: String

  # Whether this product will be shown in the generated sitemap
  shouldAppearInSitemap: Boolean

  # A URL-safe and human-readable string that uniquely identifies this product
  slug: String

  # When a shopper purchases this product, what types of fulfillment can they choose from?
  supportedFulfillmentTypes: [FulfillmentType]

  # The list of tag IDs that have been applied to this product
  tagIds: [ID]

  # Product title
  title: String

  # Twitter message
  twitterMsg: String

  # The product vendor or manufacturer, for display
  vendor: String
}

# Response payload of `createProduct` mutation
type CreateProductPayload {
  # The same string you sent with the mutation params, for matching mutation calls with their responses
  clientMutationId: String

  # The created product
  product: Product!
}

# Input for the `createProductVariant` mutation
input CreateProductVariantInput {
  # ID of product variant belongs to
  productId: ID!

  # ID of shop product variant will belong to
  shopId: ID!

  # Variant input
  variant: ProductVariantInput
}

# Mutation input for a product variant or option
input ProductVariantInput {
  # Any string to use as the internal ID for a new variant. Do not prefix or base64 encode this ID.
  # This field is allowed only when creating a variant. If you include an ID for an update, you
  # will get an error. The string must also be different from any existing product, variant, or
  # option internal ID or you will get a duplicate ID error. If you do not include this when creating
  # a variant, a random unique string is generated for you.
  _id: String

  # The attribute label describes the category of variant, for example, `Color` or `Size`.
  # In most cases this will be the same for all variants at the same level.
  attributeLabel: String

  # The product variant barcode value, if it has one
  barcode: String

  # The height of the product variant, if it has physical dimensions
  height: Float

  # The position of this variant among other variants at the same level of the product-variant-option hierarchy
  index: Int

  # True if this variant was deleted. Deleted variants are not published to the catalog.
  isDeleted: Boolean

  # True if this variant is visible. Hidden variants are not published to the catalog.
  isVisible: Boolean

  # The length of the product, if it has physical dimensions
  length: Float

  # Arbitrary additional metadata about this product
  metafields: [MetafieldInput]

  # The minimum quantity that must be added to a cart
  minOrderQuantity: Int

  # A short title to use for product detail select lists
  optionTitle: String

  # The country of origin
  originCountry: String

  # SKU of variant
  sku: String

  # The full variant title for use on cart, checkout, and order summaries and on invoices.
  # This fully describes the configured variant. For example, if this is an option with
  # `optionTitle` `Large`, its parent variant has `optionTitle` `Red`, and the product
  # `title` is `Fancy T-Shirt`, then this `title` will be something like `Fancy T-Shirt - Red - Large`.
  title: String

  # The weight of the product on Earth, if it has physical dimensions
  weight: Float

  # The width of the product, if it has physical dimensions
  width: Float

  # Variant compareAtPrice. DEPRECATED. Use the `updateProductVariantPrices` mutation to set product variant prices.
  compareAtPrice: Float

  # Variant price. DEPRECATED. Use the `updateProductVariantPrices` mutation to set product variant prices.
  price: Float

  # Whether this variant is taxable
  isTaxable: Boolean

  # Tax code
  taxCode: String

  # Tax description
  taxDescription: String
}

# Response payload of `createProductVariant` mutation
type CreateProductVariantPayload {
  # The same string you sent with the mutation params, for matching mutation calls with their responses
  clientMutationId: String

  # The created product variant
  variant: ProductVariant!
}

# Input for the `cloneProducts` mutation
input CloneProductsInput {
  # Array of IDs of products to clone
  productIds: [ID]!

  # ID of shop that owns all products you are cloning
  shopId: ID!
}

# Response payload of `cloneProducts` mutation
type CloneProductsPayload {
  # The same string you sent with the mutation params, for matching mutation calls with their responses
  clientMutationId: String

  # Array of newly cloned products
  products: [Product]!
}

# Input for the `cloneProductVariants` mutation
input CloneProductVariantsInput {
  # ID of shop that owns all product variants you want to clone
  shopId: ID!

  # Array of IDs of variants to clone
  variantIds: [ID]!
}

# Response payload of `cloneProductVariants` mutation
type CloneProductVariantsPayload {
  # The same string you sent with the mutation params, for matching mutation calls with their responses
  clientMutationId: String

  # Array of newly cloned product variants
  variants: [ProductVariant]!
}

# Input for the `updateProduct` mutation
input UpdateProductInput {
  # Product input
  product: ProductInput!

  # ID of product to update
  productId: ID!

  # ID of shop that owns the product to update
  shopId: ID!
}

# Response payload of `updateProduct` mutation
type UpdateProductPayload {
  # The same string you sent with the mutation params, for matching mutation calls with their responses
  clientMutationId: String

  # Updated product
  product: Product!
}

# Input for the `updateProductVariantField` mutation
input UpdateProductVariantInput {
  # ID of shop that owns the variant to update
  shopId: ID!

  # Variant input
  variant: ProductVariantInput!

  # ID of variant to update
  variantId: ID!
}

# Response payload of `updateProductVariantField` mutation
type UpdateProductVariantPayload {
  # The same string you sent with the mutation params, for matching mutation calls with their responses
  clientMutationId: String

  # Updated variant
  variant: ProductVariant!
}

# Input for adding tags to products in bulk
input ProductTagsOperationInput {
  # An optional string identifying the mutation call, which will be returned in the response payload
  clientMutationId: String

  # An array of product productIds to which an array of tags will be added
  productIds: [ID]

  # The shop id
  shopId: ID!

  # An array of tag ids to add to an array of products
  tagIds: [ID]
}

# Response payload managing tags on products
type ProductTagsOperationPayload {
  # The same string you sent with the mutation params, for matching mutation calls with their responses
  clientMutationId: String

  # The number of products found
  foundCount: Int

  # The number of products for which a match was not found
  notFoundCount: Int

  # The number of products successfully updated
  updatedCount: Int

  # An array of write errors if any were generated
  writeErrors: [WriteError]
}

# A bulk write error type
type WriteError {
  # The documentId(_id) on which the error occurred
  documentId: Int

  # Error message for a documentId
  errorMsg: String
}

# Input for `addTag` mutation
input AddTagInput {
  # An optional string identifying the mutation call, which will be returned in the response payload
  clientMutationId: String

  # Title to display to customers
  displayTitle: String

  # Hero media URL
  heroMediaUrl: String

  # Whether the tag is visible
  isVisible: Boolean!

  # Tag metafields
  metafields: [MetafieldInput]

  # Unique name of the tag
  name: String!

  # The shop that owns the tag
  shopId: ID!

  # The tag slug. If left blank, the name will be slugified and saved as the slug
  slug: String
}

# Response payload for `addTag` mutation
type AddTagPayload {
  # The same string you sent with the mutation params, for matching mutation calls with their responses
  clientMutationId: String

  # The shop that owns the tag
  shopId: ID!

  # The newly-created tag
  tag: Tag!
}

# Input for `removeTag` mutation
input RemoveTagInput {
  # An optional string identifying the mutation call, which will be returned in the response payload
  clientMutationId: String

  # ID of tag to delete
  id: ID!

  # The shop that owns the tag
  shopId: ID!
}

# Response payload for `removeTag` mutation
type RemoveTagPayload {
  # The same string you sent with the mutation params, for matching mutation calls with their responses
  clientMutationId: String

  # The deleted tag
  tag: Tag!
}

# Input for `setTagHeroMedia` mutation
input SetTagHeroMediaInput {
  # An optional string identifying the mutation call, which will be returned in the response payload
  clientMutationId: String

  # File record document
  fileRecord: JSONObject

  # ID of tag to add the hero image record to
  id: ID!

  # The shop that owns the tag
  shopId: ID!
}

# Response payload for `setTagHeroMedia` mutation
type SetTagHeroMediaPayload {
  # The same string you sent with the mutation params, for matching mutation calls with their responses
  clientMutationId: String

  # Tag the hero image was added to
  tag: Tag!
}

# Input for `updateTag` mutation
input UpdateTagInput {
  # An optional string identifying the mutation call, which will be returned in the response payload
  clientMutationId: String

  # Title to display to customers
  displayTitle: String

  # A list of the IDs of top products in this tag
  featuredProductIds: [ID]

  # Hero media URL
  heroMediaUrl: String

  # ID of rule to modify
  id: ID!

  # Whether the tag is visible
  isVisible: Boolean!

  # Tag metafields
  metafields: [MetafieldInput]

  # Unique name of the tag
  name: String!

  # The shop that owns the tag
  shopId: ID!

  # The tag slug. If left blank, the name will be slugified and saved as the slug
  slug: String
}

# Response payload for `updateTag` mutation
type UpdateTagPayload {
  # The same string you sent with the mutation params, for matching mutation calls with their responses
  clientMutationId: String

  # The updated tag
  tag: Tag!
}

# Input for the `updateProductVariantField` mutation
input UpdateProductVariantPricesInput {
  # Prices to update
  prices: ProductVariantPricesInput!

  # ID of shop that owns the variant to update
  shopId: ID!

  # ID of variant to update
  variantId: ID!
}

# Mutation input for a product variant or option
input ProductVariantPricesInput {
  # Variant compareAtPrice
  compareAtPrice: Float

  # Variant price
  price: Float
}

# Response payload of `updateProductVariantPricesField` mutation
type UpdateProductVariantPricesPayload {
  # The same string you sent with the mutation params, for matching mutation calls with their responses
  clientMutationId: String

  # Updated variant
  variant: ProductVariant!
}

# Input for the `recalculateReservedSimpleInventory` mutation
input RecalculateReservedSimpleInventoryInput {
  # The product and chosen options this info applies to
  productConfiguration: ProductConfigurationInput!

  # Shop that owns the product
  shopId: ID!
}

# Response payload for the `updateSimpleInventory` mutation
type RecalculateReservedSimpleInventoryPayload {
  # The same string you sent with the mutation params, for matching mutation calls with their responses
  clientMutationId: String

  # The updated inventory info
  inventoryInfo: SimpleInventoryInfo!
}

# Input for the `updateSimpleInventory` mutation. In addition to `shopId`, at least one field to update is required.
input UpdateSimpleInventoryInput {
  # Whether to allow ordering this product configuration when there is insufficient quantity available.
  # Set this to `true` or `false` if you want to update it.
  canBackorder: Boolean

  # An optional string identifying the mutation call, which will be returned in the response payload
  clientMutationId: String

  # Current quantity of this product configuration in stock. Set this to an integer if you want to update it.
  inventoryInStock: Int

  # Whether the SimpleInventory plugin should manage inventory for this product configuration.
  # Set this to `true` or `false` if you want to update it.
  isEnabled: Boolean

  # The "low quantity" flag will be applied to this product configuration when the available quantity
  # is at or below this threshold. Set this to an integer if you want to update it.
  lowInventoryWarningThreshold: Int

  # The product and chosen options this info applies to
  productConfiguration: ProductConfigurationInput!

  # Shop that owns the product
  shopId: ID!
}

# Response payload for the `updateSimpleInventory` mutation
type UpdateSimpleInventoryPayload {
  # The same string you sent with the mutation params, for matching mutation calls with their responses
  clientMutationId: String

  # The updated inventory info
  inventoryInfo: SimpleInventoryInfo!
}

# Input for the `addCartItems` mutation
input AddCartItemsInput {
  # The cart ID
  cartId: ID!

  # If this cart is anonymous, provide the `cartToken` that was returned in the `CreateCartPayload`
  cartToken: String

  # An optional string identifying the mutation call, which will be returned in the response payload
  clientMutationId: String

  # Array of items to be added to the cart
  items: [CartItemInput]!
}

# Information about an item to add to a cart
input CartItemInput {
  # Arbitrary additional metadata about this cart item.
  metafields: [MetafieldInput]

  # The price of this item, for validating that this matches the actual price in the system,
  # in case the client has stale data.
  price: MoneyInput!

  # The product and chosen options
  productConfiguration: ProductConfigurationInput!

  # The number of this item to add to the cart
  quantity: Int!
}

# Represents input for some amount of a single currency
input MoneyInput {
  # The numeric amount
  amount: Float!

  # The currency code, for interpreting the `amount`
  currencyCode: String!
}

# The payload returned from the `addCartItems` mutation call
type AddCartItemsPayload {
  # The modified cart. You should check `incorrectPriceFailures` and `minOrderQuantityFailures` for
  # information necessary to display errors to the shopper. Some items may not have been added.
  cart: Cart

  # The same string you sent with the mutation params, for matching mutation calls with their responses
  clientMutationId: String

  # Clients should check to see if any items failed to be added due to the price not matching the current price.
  # In general, a user interface should display the correct current prices to the shopper, confirm that they still
  # want to add the items, and then call `createCart` or `addCartItems` to do so.
  #
  # Note that this field will always exist but may be an empty array if there were no failures of this type.
  incorrectPriceFailures: [IncorrectPriceFailureDetails]!

  # Clients should check to see if any items failed to be added due to quantity being below the minimum order
  # quantity defined for the product variant. In general, a user interface should display the minimum order
  # quantity to the shopper and allow them to add that quantity or greater.
  #
  # Note that this field will always exist but may be an empty array if there were no failures of this type.
  minOrderQuantityFailures: [MinOrderQuantityFailureDetails]!
}

# Details about a CartItemInput that failed to be added to a cart due to a price mismatch
type IncorrectPriceFailureDetails {
  # The current price in the system for this product configuration in the requested currency
  currentPrice: Money!

  # The productConfiguration that was provided with the CartItemInput that caused this failure
  productConfiguration: ProductConfiguration!

  # The price that was provided with the CartItemInput that caused this failure
  providedPrice: Money!
}

# Details about a CartItemInput that failed to be added to a cart due to a quantity error
type MinOrderQuantityFailureDetails {
  # The minimum quantity that can be added to a cart
  minOrderQuantity: Int!

  # The productConfiguration that was provided with the CartItemInput that caused this failure
  productConfiguration: ProductConfiguration!

  # The quantity that was provided with the CartItemInput that caused this failure
  quantity: Int!
}

# The input necessary to create a cart
input CreateCartInput {
  # An optional string identifying the mutation call, which will be returned in the response payload
  clientMutationId: String

  # Array of items to add to new cart.
  items: [CartItemInput]!

  # ShopId association for the cart.
  shopId: ID!
}

# The payload returned from the `createCart` mutation call
type CreateCartPayload {
  # The created cart, if at least one item could be added. Otherwise null, and you should check
  # `incorrectPriceFailures` and `minOrderQuantityFailures` for information necessary to display
  # errors to the shopper.
  cart: Cart

  # The same string you sent with the mutation params, for matching mutation calls with their responses
  clientMutationId: String

  # Clients should check to see if any items failed to be added due to the price not matching the current price.
  # In general, a user interface should display the correct current prices to the shopper, confirm that they still
  # want to add the items, and then call `createCart` or `addCartItems` to do so.
  #
  # Note that this field will always exist but may be an empty array if there were no failures of this type.
  incorrectPriceFailures: [IncorrectPriceFailureDetails]!

  # Clients should check to see if any items failed to be added due to quantity being below the minimum order
  # quantity defined for the product variant. In general, a user interface should display the minimum order
  # quantity to the shopper and allow them to add that quantity or greater.
  #
  # Note that this field will always exist but may be an empty array if there were no failures of this type.
  minOrderQuantityFailures: [MinOrderQuantityFailureDetails]!

  # If no identity token is provided with the request, then this mutation will create an anonymous cart. All
  # anonymous carts have a token associated with them, which allows the client that created the cart to access
  # that cart in the future. This is the only time this token is returned, so clients must store this securely
  # in some type of local storage solution, and then send it along with all future anonymous cart queries and
  # mutations.
  token: String
}

# Input for the `reconcileCarts` mutation call
input ReconcileCartsInput {
  # An anonymous cart ID
  anonymousCartId: ID!

  # An anonymous cart token
  cartToken: String!

  # An optional string identifying the mutation call, which will be returned in the response payload
  clientMutationId: String

  # If both an anonymous cart and a cart for the authenticated account are found, how do we combine them?
  # Default mode is `merge`, where all anonymous items are moved into the account cart along with existing
  # account cart items, and quantities are combined.
  mode: CartReconciliationMode

  # The ID of the shop that owns both carts
  shopId: ID!
}

# Supported cart reconciliation modes
enum CartReconciliationMode {
  # Delete the anonymous cart and use the account cart.
  keepAccountCart

  # Assign the anonymous cart to the account, and delete the account cart.
  keepAnonymousCart

  # Move all items from the anonymous cart into the account cart along with existing
  # account cart items. If the same item is in both carts, combine the quantities.
  merge
}

# The payload returned from the `reconcileCarts` mutation call
type ReconcileCartsPayload {
  # The account cart, potentially modified
  cart: Cart!

  # The same string you sent with the mutation params, for matching mutation calls with their responses
  clientMutationId: String
}

# Input for the `removeCartItems` mutation
input RemoveCartItemsInput {
  # The cart ID
  cartId: ID!

  # Array of items to remove from the cart.
  cartItemIds: [ID]!

  # If this cart is anonymous, provide the `cartToken` that was returned in the `CreateCartPayload`
  cartToken: String

  # An optional string identifying the mutation call, which will be returned in the response payload
  clientMutationId: String
}

# The payload returned from the `removeCartItems` mutation call
type RemoveCartItemsPayload {
  # The modified cart
  cart: Cart!

  # The same string you sent with the mutation params, for matching mutation calls with their responses
  clientMutationId: String
}

# Input for the `setEmailOnAnonymousCart` mutation call
input SetEmailOnAnonymousCartInput {
  # An anonymous cart ID
  cartId: ID!

  # Provide the `cartToken` that was returned in the `CreateCartPayload`
  cartToken: String!

  # An optional string identifying the mutation call, which will be returned in the response payload
  clientMutationId: String

  # The email address to associate with this cart. This address is used for order communication and
  # other fulfillment purposes.
  email: String!
}

# The payload returned from the `setEmailOnAnonymousCart` mutation call
type SetEmailOnAnonymousCartPayload {
  # The modified cart
  cart: Cart!

  # The same string you sent with the mutation params, for matching mutation calls with their responses
  clientMutationId: String
}

# Input for the `updateCartItemsQuantity` mutation
input UpdateCartItemsQuantityInput {
  # The cart ID
  cartId: ID!

  # If this cart is anonymous, provide the `cartToken` that was returned in the `CreateCartPayload`
  cartToken: String

  # An optional string identifying the mutation call, which will be returned in the response payload
  clientMutationId: String

  # Array of cart item quantities to update.
  items: [UpdateCartItemInput]!
}

# Input for the `updateCartItem` mutation
input UpdateCartItemInput {
  # The cart item ID
  cartItemId: ID!

  # New absolute value for specified cart item's quantity. Not an incremental value.
  quantity: Int!
}

# The payload returned from the `updateCartItemsQuantity` mutation call
type UpdateCartItemsQuantityPayload {
  # The modified cart
  cart: Cart!

  # The same string you sent with the mutation params, for matching mutation calls with their responses
  clientMutationId: String
}

# Input needed to select a fulfillment option for a single fulfillment group on a cart
input SelectFulfillmentOptionForGroupInput {
  # The cart to select this option for
  cartId: ID!

  # The token for the cart, required if it is an anonymous cart
  cartToken: String

  # An optional string identifying the mutation call, which will be returned in the response payload
  clientMutationId: String

  # The group to select this option for
  fulfillmentGroupId: ID!

  # The fulfillment method ID from the option the shopper selected
  fulfillmentMethodId: ID!
}

# The response from the `selectFulfillmentOptionForGroup` mutation
type SelectFulfillmentOptionForGroupPayload {
  # The updated Cart
  cart: Cart!

  # The same string you sent with the mutation params, for matching mutation calls with their responses
  clientMutationId: String
}

# Input needed when setting the shipping address on a cart
input SetShippingAddressOnCartInput {
  # The shipping address
  address: AddressInput!

  # If set, this will be saved as the Address._id. Otherwise an ID will be generated.
  addressId: String

  # The cart to set shipping address on
  cartId: ID!

  # The token for the cart, required if it is an anonymous cart
  cartToken: String

  # An optional string identifying the mutation call, which will be returned in the response payload
  clientMutationId: String
}

# The response from the `setShippingAddressOnCart` mutation
type SetShippingAddressOnCartPayload {
  # The updated Cart
  cart: Cart!

  # The same string you sent with the mutation params, for matching mutation calls with their responses
  clientMutationId: String
}

# A request to update the available fulfillment options for a single fulfillment group
input UpdateFulfillmentOptionsForGroupInput {
  # The cart to update fulfillment options for
  cartId: ID!

  # The token for the cart, required if it is an anonymous cart
  cartToken: String

  # An optional string identifying the mutation call, which will be returned in the response payload
  clientMutationId: String

  # The group to update fulfillment options for
  fulfillmentGroupId: ID!
}

# The response from the `updateFulfillmentOptionsForGroup` mutation
type UpdateFulfillmentOptionsForGroupPayload {
  # The updated Cart
  cart: Cart!

  # The same string you sent with the mutation params, for matching mutation calls with their responses
  clientMutationId: String
}

# Input for the addOrderFulfillmentGroup mutation
input AddOrderFulfillmentGroupInput {
  # An optional string identifying the mutation call, which will be returned in the response payload
  clientMutationId: String

  # The order fulfillment group input, used to build the new group
  fulfillmentGroup: OrderFulfillmentGroupExistingOrderInput!

  # Optional list of order item IDs that should be moved from an existing group to the new group
  moveItemIds: [ID]

  # ID of the order that has the item you want to add the group to
  orderId: ID!
}

# Similar to `OrderFulfillmentGroupInput` but `items` can be omitted if moving existing items to the new group
input OrderFulfillmentGroupExistingOrderInput {
  # Information needed by the selected fulfillment method to properly fulfill the order
  data: OrderFulfillmentGroupDataInput

  # The list of items to be ordered
  items: [OrderFulfillmentGroupItemInput]

  # The ID of the fulfillment method to be used for this order group
  selectedFulfillmentMethodId: ID!

  # The shop that owns these items and needs to fulfill this part of the order
  shopId: ID!

  # The total price of the items, fulfillment, and taxes, for this group, less any discounts, in the
  # `order.currencyCode` currency. This value is not trusted; the actual total is calculated by the
  # Order service. However, providing this value prevents an order being created for an amount that
  # does not match what was shown to the shopper in order preview.
  totalPrice: Float

  # The fulfillment type. Any valid type that has been registered by a fulfillment plugin. Examples: `shipping`, `digital`
  type: FulfillmentType!
}

# Information needed by the selected fulfillment method to properly fulfill the order
input OrderFulfillmentGroupDataInput {
  # The mailing address to which this fulfillment group should be shipped
  shippingAddress: AddressInput
}

# Input for an `OrderFulfillmentGroupItem`
input OrderFulfillmentGroupItemInput {
  # The date and time at which this item was first added to the source cart, if this is something you want to track
  addedAt: DateTime

  # The price of the item, in the `order.currencyCode` currency. This value is not trusted; the actual price
  # is confirmed by the Order service. However, providing this value prevents an order being created for an
  # amount that does not match what was shown to the shopper in order preview.
  price: Float!

  # The product and chosen options
  productConfiguration: ProductConfigurationInput!

  # The desired quantity of this item. This must be a positive integer.
  quantity: Int!
}

# Response payload for the addOrderFulfillmentGroup mutation
type AddOrderFulfillmentGroupPayload {
  # The same string you sent with the mutation params, for matching mutation calls with their responses
  clientMutationId: String

  # ID of the added fulfillment group
  newFulfillmentGroupId: ID!

  # The updated order
  order: Order!
}

# Input for the cancelOrderItem mutation
input CancelOrderItemInput {
  # Quantity to cancel. Must be equal to or less than the item quantity.
  cancelQuantity: Int!

  # An optional string identifying the mutation call, which will be returned in the response payload
  clientMutationId: String

  # ID of the item order you want to cancel
  itemId: ID!

  # ID of the order that has the item you want to cancel
  orderId: ID!

  # An optional free text reason for cancellation, which may be shown to operators
  # or to the user who placed the order.
  reason: String
}

# Response payload for the cancelOrderItem mutation
type CancelOrderItemPayload {
  # The same string you sent with the mutation params, for matching mutation calls with their responses
  clientMutationId: String

  # The updated order
  order: Order!
}

# Input for the cancelOrderItem mutation
input CreateRefundInput {
  # Amount to cancel. Must be equal to or less than the remaining non-refunded payment amount for this payment method.
  amount: Float!

  # ID of the order that has the item you want to cancel
  orderId: ID!

  # ID of the payment that you want to refund
  paymentId: ID!

  # An optional free text reason for refund, which may be shown to operators
  # or to the user who requested the refund.
  reason: String
}

# Response payload for the createRefund mutation
type CreateRefundPayload {
  # The same string you sent with the mutation params, for matching mutation calls with their responses
  clientMutationId: String

  # The updated order
  order: Order!
}

# Input for the moveOrderItems mutation
input MoveOrderItemsInput {
  # An optional string identifying the mutation call, which will be returned in the response payload
  clientMutationId: String

  # The ID of the order fulfillment group from which all the items are to be moved.
  fromFulfillmentGroupId: ID!

  # The list of item IDs to move. The full quantity must be moved.
  itemIds: [ID]!

  # ID of the order that has the items you want to move
  orderId: ID!

  # The ID of the order fulfillment group to which all the items are to be moved.
  toFulfillmentGroupId: ID!
}

# Response payload for the moveOrderItems mutation
type MoveOrderItemsPayload {
  # The same string you sent with the mutation params, for matching mutation calls with their responses
  clientMutationId: String

  # The updated order
  order: Order!
}

# Input for the placeOrder mutation
input PlaceOrderInput {
  # An optional string identifying the mutation call, which will be returned in the response payload
  clientMutationId: String

  # The order to be placed, if payment is accepted
  order: OrderInput!

  # The information necessary to pay. Collect this information from the shopper during a checkout flow.
  # You need not provide any payment input if the total is zero.
  # The total of all payment input `amount` fields must add up to the order total. The first payment
  # method where the `amount` field is `null` will be charged the remainder due.
  payments: [PaymentInput]
}

# Input for placing an order
input OrderInput {
  # The ID of the cart that is becoming an order. This is optional, and you can create an order without ever
  # creating a cart. If you do have a cart, there are two good reasons to provide this. First, it serves as a
  # reference. Second, it allows the Cart service to automatically delete the related cart after the order is
  # created.
  cartId: String

  # The code for the currency in which all values are being provided
  currencyCode: String!

  # An email address to use for order tracking and correspondence. If a logged in user is placing an order,
  # we recommend that you use their "orders" email address, if they have one, or their default email address.
  # Or you can ask them to provide any email address.
  email: String!

  # One or more fulfillment groups for the order. These are the actual orders that need to be fulfilled,
  # separate by shop, fulfillment type, and shipping origin or destination.
  fulfillmentGroups: [OrderFulfillmentGroupInput]!

  # The shop through which the order should be placed. Payment settings from this shop will be used. Note that
  # each fulfillment group also has a shop ID, which represents the shop that needs to fulfill that part of the
  # order, and those shop IDs may or may not match this one.
  shopId: String!
}

# Input for an `OrderFulfillmentGroup`
input OrderFulfillmentGroupInput {
  # Information needed by the selected fulfillment method to properly fulfill the order
  data: OrderFulfillmentGroupDataInput

  # The list of items to be ordered
  items: [OrderFulfillmentGroupItemInput]!

  # The ID of the fulfillment method to be used for this order group
  selectedFulfillmentMethodId: ID!

  # The shop that owns these items and needs to fulfill this part of the order
  shopId: ID!

  # The total price of the items, fulfillment, and taxes, for this group, less any discounts, in the
  # `order.currencyCode` currency. This value is not trusted; the actual total is calculated by the
  # Order service. However, providing this value prevents an order being created for an amount that
  # does not match what was shown to the shopper in order preview.
  totalPrice: Float

  # The fulfillment type. Any valid type that has been registered by a fulfillment plugin. Examples: `shipping`, `digital`
  type: FulfillmentType!
}

# Input for adding order payments
input PaymentInput {
  # Amount to charge, which must be less than or equal to the order total. This is assumed
  # to be in the same currency as the order. Set to `null` to charge the remaining amount
  # to this payment method, which might be the full order total if this is the only payment.
  amount: Float!

  # The billing address entered by the shopper. If omitted, the billing address on the order input
  # will be used. Some payment methods may not require a billing address but others will fail
  # authorization without one, so be sure that client UI code is aware of which payment methods
  # require collecting one.
  billingAddress: AddressInput

  # Any additional user-provided input necessary to authorize and capture the payment
  data: JSONObject

  # The name of the payment method to use for this payment
  method: PaymentMethodName!
}

# The name of a payment method, which is how payment methods are keyed
enum PaymentMethodName {
  # IOU Example payment method
  iou_example

  # Stripe payment method
  stripe_payment_intent

  # No payment method
  none
}

# Response payload for the placeOrder mutation
type PlaceOrderPayload {
  # The same string you sent with the mutation params, for matching mutation calls with their responses
  clientMutationId: String

  # Orders that were created
  orders: [Order]!

  # If you are not logged in, this will be a token that can be used for future requests
  token: String
}

# Input for the splitOrderItem mutation
input SplitOrderItemInput {
  # An optional string identifying the mutation call, which will be returned in the response payload
  clientMutationId: String

  # ID of the item order you want to split
  itemId: ID!

  # The quantity that will be transferred to a new order item on the same fulfillment group.
  newItemQuantity: Int!

  # ID of the order that has the item you want to split
  orderId: ID!
}

# Response payload for the splitOrderItem mutation
type SplitOrderItemPayload {
  # The same string you sent with the mutation params, for matching mutation calls with their responses
  clientMutationId: String

  # The ID of the new order item that was created
  newItemId: ID!

  # The updated order
  order: Order!
}

# Input for the updateOrder mutation
input UpdateOrderInput {
  # An optional string identifying the mutation call, which will be returned in the response payload
  clientMutationId: String

  # Set the order email to this
  email: String

  # ID of the order to update
  orderId: ID!

  # Set the current order status to this
  status: String
}

# Response payload for the updateOrder mutation
type UpdateOrderPayload {
  # The same string you sent with the mutation params, for matching mutation calls with their responses
  clientMutationId: String

  # The updated order
  order: Order!
}

# Input for the updateOrderFulfillmentGroup mutation
input UpdateOrderFulfillmentGroupInput {
  # An optional string identifying the mutation call, which will be returned in the response payload
  clientMutationId: String

  # ID of the order fulfillment group to update
  orderFulfillmentGroupId: ID!

  # ID of the order to update
  orderId: ID!

  # Set the current order fulfillment group status to this
  status: String

  # Set this as the current order fulfillment group shipment tracking reference
  tracking: String

  # Set this as the current order fulfillment group shipment tracking URL
  trackingUrl: String
}

# Response payload for the updateOrderFulfillmentGroup mutation
type UpdateOrderFulfillmentGroupPayload {
  # The same string you sent with the mutation params, for matching mutation calls with their responses
  clientMutationId: String

  # The updated order
  order: Order!
}

# Input for the `approveOrderPayments` mutation
input ApproveOrderPaymentsInput {
  # An optional string identifying the mutation call, which will be returned in the response payload
  clientMutationId: String

  # The order ID
  orderId: ID!

  # The IDs of one or more payments to approve for this order
  paymentIds: [ID]!

  # The ID of the shop that owns this order
  shopId: ID!
}

# Response from the `approveOrderPayments` mutation
type ApproveOrderPaymentsPayload {
  # The same string you sent with the mutation params, for matching mutation calls with their responses
  clientMutationId: String

  # The updated order
  order: Order!
}

# Input for the `captureOrderPayments` mutation
input CaptureOrderPaymentsInput {
  # An optional string identifying the mutation call, which will be returned in the response payload
  clientMutationId: String

  # The order ID
  orderId: ID!

  # The IDs of one or more payments to capture for this order
  paymentIds: [ID]!

  # The ID of the shop that owns this order
  shopId: ID!
}

# Response from the `captureOrderPayments` mutation
type CaptureOrderPaymentsPayload {
  # The same string you sent with the mutation params, for matching mutation calls with their responses
  clientMutationId: String

  # The updated order
  order: Order!
}

# Input for the `enablePaymentMethodForShop` mutation
input EnablePaymentMethodForShopInput {
  # An optional string identifying the mutation call, which will be returned in the response payload
  clientMutationId: String

  # True to enable it or false to disable it
  isEnabled: Boolean!

  # The name of the payment method to enable or disable
  paymentMethodName: String!

  # The ID of the shop for which this payment method should be enabled or disabled
  shopId: ID!
}

# Response payload for the `enablePaymentMethodForShop` mutation
type EnablePaymentMethodForShopPayload {
  # The same string you sent with the mutation params, for matching mutation calls with their responses
  clientMutationId: String

  # The full list of payment methods for the shop
  paymentMethods: [PaymentMethod]!
}

# Input for the createStripePaymentIntent mutation
input CreateStripePaymentIntentInput {
  # An optional string identifying the mutation call, which will be returned in the response payload
  clientMutationId: String

  #
  cartId: String!

  #
  shopId: String!

  # If this cart is anonymous, provide the `token` that was returned in the `CreateCartPayload`
  cartToken: String
}

# The response from the `createStripePaymentIntent` mutation
type CreateStripePaymentIntentPayload {
  #
  paymentIntentClientSecret: String

  # The same string you sent with the mutation params, for matching mutation calls with their responses
  clientMutationId: String
}

# Describes the input for creating a discount code
input CreateDiscountCodeInput {
  # An optional string identifying the mutation call, which will be returned in the response payload
  clientMutationId: String

  # The discount code to update
  discountCode: DiscountCodeInput

  # The shop ID of the discount code to update
  shopId: ID!
}

# Input type for a discount code
input DiscountCodeInput {
  # How the discount should be applied
  calculation: DiscountCalculationInput

  # Discount Code
  code: String!

  # Discount code conditions
  conditions: DiscountConditionsInput

  # Description to describe the discount code
  description: String

  # Discount is allowed to be string or number.
  # it's a formula value (could be shipping code)
  discount: String

  # Discount method type
  discountMethod: DiscountMethod

  # Label to describe the code
  label: String

  # History of transactions
  transactions: [DiscountTransactionInput]
}

# Input type for discount calculation
input DiscountCalculationInput {
  # Discount code calculation method
  method: DiscountCalculationMethod
}

# Discount conditions input type
input DiscountConditionsInput {
  # Account Limit
  accountLimit: Int

  # Audience that may apply this discount code
  audience: [String]

  # Is this discount code enabled
  enabled: Boolean!

  # Order conditions
  order: DiscountConditionOrderInput

  # Permissions that may apply this discount code
  permissions: [String]

  # Products that may apply this discount code
  products: [String]

  # Number of times this code may be redeemed.
  # Setting to 100 means the first 100 customers may apply this code.
  # Setting this value to 0 will allow this code to be applied an infinite number of times.
  redemptionLimit: Int

  # Tags that may be apply this discount code
  tags: [String]
}

# Discount order conditions input type
input DiscountConditionOrderInput {
  # Order date range end
  endDate: DateTime

  # Maximum order value
  max: Float

  # Minimum order value
  min: Float!

  # Order date range start
  startDate: DateTime
}

# Discount transation input type
input DiscountTransactionInput {
  # Date the code was applied
  appliedAt: DateTime

  # Cart id
  cartId: String!

  # User id
  userId: String!
}

# The response from the `createDiscountCode` mutation
type CreateDiscountCodePayload {
  # The same string you sent with the mutation params, for matching mutation calls with their responses
  clientMutationId: String

  # The created discount code
  discountCode: DiscountCode
}

# Describes the input for updating a discount code
input UpdateDiscountCodeInput {
  # An optional string identifying the mutation call, which will be returned in the response payload
  clientMutationId: String

  # The discount code to update
  discountCode: DiscountCodeInput

  # The ID of the discount code to update
  discountCodeId: ID!

  # The shop ID of the discount code to update
  shopId: ID!
}

# The response from the `updateDiscountCode` mutation
type UpdateDiscountCodePayload {
  # The same string you sent with the mutation params, for matching mutation calls with their responses
  clientMutationId: String

  # The updated discount code
  discountCode: DiscountCode
}

# Describes the input for removing a discount code
input DeleteDiscountCodeInput {
  # An optional string identifying the mutation call, which will be returned in the response payload
  clientMutationId: String

  # The discount code ID
  discountCodeId: ID!

  # Shop ID
  shopId: ID!
}

# The response from the `deleteDiscountCode` mutation
type DeleteDiscountCodePayload {
  # The same string you sent with the mutation params, for matching mutation calls with their responses
  clientMutationId: String

  # The deleted discount code
  discountCode: DiscountCode
}

# Input for an `ApplyDiscountCodeToCartInput`
input ApplyDiscountCodeToCartInput {
  # Cart to add discount to
  cartId: ID!

  # Discount code to add to cart
  discountCode: String!

  # Shop cart belongs to
  shopId: ID!

  # Cart token, if anonymous
  token: String
}

# Response from the `applyDiscountCodeToCart` mutation
type ApplyDiscountCodeToCartPayload {
  # The updated cart with discount code applied
  cart: Cart!

  # The same string you sent with the mutation params, for matching mutation calls with their responses
  clientMutationId: String
}

# Input for an `RemoveDiscountCodeFromCartInput`
input RemoveDiscountCodeFromCartInput {
  # Cart to add discount to
  cartId: ID!

  # ID of the discount you want to remove from the cart
  discountId: ID!

  # Shop cart belongs to
  shopId: ID!

  # Cart token, if anonymous
  token: String
}

# Response from the `removeDiscountCodeFromCart` mutation
type RemoveDiscountCodeFromCartPayload {
  # The updated cart with discount code removed
  cart: Cart!

  # The same string you sent with the mutation params, for matching mutation calls with their responses
  clientMutationId: String
}

# Input for the `CreateSurcharge` mutation
input CreateSurchargeInput {
  # An optional string identifying the mutation call, which will be returned in the response payload
  clientMutationId: String

  # The shop to create this surcharge for
  shopId: ID!

  # This defines the surcharge that you want to create
  surcharge: SurchargeInput!
}

# Defines a surcharge.
input SurchargeInput {
  # Amount.
  amount: Float!

  # Attribute restrictions.
  attributes: [SurchargeAttributeRestrictionsInput]

  # Destination restrictions.
  destination: SurchargeDestinationRestrictionsInput

  # Messages by language.
  messagesByLanguage: [MessagesByLanguageInput]!

  # Method IDs to apply this surcharge to.
  methodIds: [ID]

  # The type of this surcharge. Allowed types are `surcharge`.
  type: SurchargeTypeEnum!
}

# Input to add a surcharge attribute restriction
input SurchargeAttributeRestrictionsInput {
  # The operator to use for value comparison
  operator: String

  # The property to check
  property: String

  # The type of this property
  propertyType: SurchargePropertyType

  # The value to check for
  value: String
}

# Input to add a surcharge destination restriction
input SurchargeDestinationRestrictionsInput {
  # Restrict for any of these destination countries
  country: [String]

  # Restrict for any of these destination postal codes
  postal: [String]

  # Restrict for any of these destination regions
  region: [String]
}

# Input to add a surcharge message with language
input MessagesByLanguageInput {
  # The message for this language
  content: String!

  # The language code
  language: String!
}

# Response from the `CreateSurcharge` mutation
type CreateSurchargePayload {
  # The same string you sent with the mutation params, for matching mutation calls with their responses
  clientMutationId: String

  # The created surcharge
  surcharge: Surcharge!
}

# Input for the `deleteSurcharge` mutation
input DeleteSurchargeInput {
  # An optional string identifying the mutation call, which will be returned in the response payload
  clientMutationId: String

  # The shop that owns the method
  shopId: ID!

  # The ID of the flat rate fulfillment method you want to delete
  surchargeId: ID!
}

# Response from the `deleteSurcharge` mutation
type DeleteSurchargePayload {
  # The same string you sent with the mutation params, for matching mutation calls with their responses
  clientMutationId: String

  # The removed fulfillment method
  surcharge: Surcharge!
}

# Input for the `updateSurcharge` mutation
input UpdateSurchargeInput {
  # An optional string identifying the mutation call, which will be returned in the response payload
  clientMutationId: String

  # The shop that owns the method
  shopId: ID!

  # The updated surcharge. Pass the whole updated surcharge object without the ID.
  surcharge: SurchargeInput!

  # The ID of the flat rate fulfillment surcharge you want to update
  surchargeId: ID!
}

# Response from the `updateFlatRateFulfillmentMethod` mutation
type UpdateSurchargePayload {
  # The same string you sent with the mutation params, for matching mutation calls with their responses
  clientMutationId: String

  # The updated fulfillment surcharge
  surcharge: Surcharge!
}

# Input for the `createFlatRateFulfillmentMethod` mutation
input CreateFlatRateFulfillmentMethodInput {
  # An optional string identifying the mutation call, which will be returned in the response payload
  clientMutationId: String

  # This defines the flat rate fulfillment method that you want to create
  method: FlatRateFulfillmentMethodInput!

  # The shop to create this flat rate fulfillment method for
  shopId: ID!
}

# Defines a fulfillment method that has a fixed price. This type is provided by the `flat-rate` fulfillment plugin.
input FlatRateFulfillmentMethodInput {
  # The cost of this fulfillment method to the shop, if you track this
  cost: Float

  # The fulfillment types for which this method may be used. For example, `shipping` or `digital`.
  fulfillmentTypes: [FulfillmentType]!

  # The group to which this method belongs
  group: String!

  # A fixed price to charge for handling costs when this fulfillment method is selected for an order
  handling: Float!

  # Include this as a fulfillment option shown to shoppers during checkout?
  isEnabled: Boolean!

  # The name of this method, for display in the user interface
  label: String!

  # The name of this method, a unique identifier
  name: String!

  # A fixed price to charge for fulfillment costs when this fulfillment method is selected for an order
  rate: Float!
}

# Response from the `createFlatRateFulfillmentMethod` mutation
type CreateFlatRateFulfillmentMethodPayload {
  # The same string you sent with the mutation params, for matching mutation calls with their responses
  clientMutationId: String

  # The created fulfillment method
  method: FlatRateFulfillmentMethod!
}

# Input for the `updateFlatRateFulfillmentMethod` mutation
input UpdateFlatRateFulfillmentMethodInput {
  # An optional string identifying the mutation call, which will be returned in the response payload
  clientMutationId: String

  # The updated method. Pass the whole updated method object without the ID.
  method: FlatRateFulfillmentMethodInput!

  # The ID of the flat rate fulfillment method you want to update
  methodId: ID!

  # The shop that owns the method
  shopId: ID!
}

# Response from the `updateFlatRateFulfillmentMethod` mutation
type UpdateFlatRateFulfillmentMethodPayload {
  # The same string you sent with the mutation params, for matching mutation calls with their responses
  clientMutationId: String

  # The updated fulfillment method
  method: FlatRateFulfillmentMethod!
}

# Input for the `deleteFlatRateFulfillmentMethod` mutation
input DeleteFlatRateFulfillmentMethodInput {
  # An optional string identifying the mutation call, which will be returned in the response payload
  clientMutationId: String

  # The ID of the flat rate fulfillment method you want to delete
  methodId: ID!

  # The shop that owns the method
  shopId: ID!
}

# Response from the `deleteFlatRateFulfillmentMethod` mutation
type DeleteFlatRateFulfillmentMethodPayload {
  # The same string you sent with the mutation params, for matching mutation calls with their responses
  clientMutationId: String

  # The removed fulfillment method
  method: FlatRateFulfillmentMethod!
}

# Input for the `CreateFlatRateFulfillmentRestriction` mutation
input CreateFlatRateFulfillmentRestrictionInput {
  # An optional string identifying the mutation call, which will be returned in the response payload
  clientMutationId: String

  # This defines the flat rate fulfillment method restriction that you want to create
  restriction: FlatRateFulfillmentRestrictionInput!

  # The shop to create this flat rate fulfillment method restriction for
  shopId: ID!
}

# Defines the input for a flat rate fulfillment method restriction.
input FlatRateFulfillmentRestrictionInput {
  # Attribute restrictions. Multiple attribute restrictions are evaluated with AND. If both destination and attribute restrictions are present, they evaluate with AND.
  attributes: [AttributeRestrictionsInput]

  # Destination restrictions. If multiple destination restrictions are present, the most localized is the only one evaluated (i.e. evaluate postal if present, then region if present, then country). If both destination and attribute restrictions are present, they evaluate with AND.
  destination: DestinationRestrictionsInput

  # Method IDs to apply this restriction to. If none, applies to all methods as a universal restriction.
  methodIds: [ID]

  # The type of this restriction. Allowed types are `allow` or `deny`.
  type: RestrictionTypeEnum!
}

# Input to create an attribute restriction condition
input AttributeRestrictionsInput {
  # The operator to use for value comparison
  operator: String!

  # The property to check
  property: String!

  # The type of this property
  propertyType: String!

  # The value to check for
  value: String!
}

# Input for a destination restriction condition
input DestinationRestrictionsInput {
  # Restrict for any of these destination countries
  country: [String]

  # Restrict for any of these destination postal codes
  postal: [String]

  # Restrict for any of these destination regions
  region: [String]
}

# Response from the `CreateFlatRateFulfillmentRestriction` mutation
type CreateFlatRateFulfillmentRestrictionPayload {
  # The same string you sent with the mutation params, for matching mutation calls with their responses
  clientMutationId: String

  # The created flat rate fulfillment method restriction
  restriction: FlatRateFulfillmentRestriction!
}

# Input for the `deleteFlatRateFulfillmentRestriction` mutation
input DeleteFlatRateFulfillmentRestrictionInput {
  # An optional string identifying the mutation call, which will be returned in the response payload
  clientMutationId: String

  # The ID of the flat rate fulfillment method restriction you want to delete
  restrictionId: ID!

  # The shop that owns the flat rate fulfillment method restriction
  shopId: ID!
}

# Response from the `deleteFlatRateFulfillmentRestriction` mutation
type DeleteFlatRateFulfillmentRestrictionPayload {
  # The same string you sent with the mutation params, for matching mutation calls with their responses
  clientMutationId: String

  # The removed flat rate fulfillment method restriction
  restriction: FlatRateFulfillmentRestriction!
}

# Input for the `updateFlatRateFulfillmentRestriction` mutation
input UpdateFlatRateFulfillmentRestrictionInput {
  # An optional string identifying the mutation call, which will be returned in the response payload
  clientMutationId: String

  # The updated flat rate fulfillment method restriction. Pass the whole updated restriction object without the ID.
  restriction: FlatRateFulfillmentRestrictionInput!

  # The ID of the flat rate fulfillment method restriction you want to update
  restrictionId: ID!

  # The shop that owns the flat rate fulfillment method restriction
  shopId: ID!
}

# Response from the `updateFlatRateFulfillmentMethod` mutation
type UpdateFlatRateFulfillmentRestrictionPayload {
  # The same string you sent with the mutation params, for matching mutation calls with their responses
  clientMutationId: String

  # The updated flat rate fulfillment method restriction
  restriction: FlatRateFulfillmentRestriction!
}

# The input for creating a tax rate
input CreateTaxRateInput {
  # An optional string identifying the mutation call, which will be returned in the response payload
  clientMutationId: String

  # An optional country code to limit where this tax is applied based on destination address
  country: String

  # An optional postal code to limit where this tax is applied based on destination address
  postal: String

  # The tax rate. For example, 0.05 for a 5% sales tax.
  rate: Float!

  # An optional region (e.g., state) to limit where this tax is applied based on destination address
  region: String

  # Shop ID
  shopId: ID!

  # Whether the `country`, `postal`, and `region` filters apply to the origin address or the destination address
  sourcing: TaxSource = destination

  # An optional tax code, to apply this tax rate to only products that have this tax code
  taxCode: String
}

# The response from the `createTaxRate` mutation
type CreateTaxRatePayload {
  # The same string you sent with the mutation params, for matching mutation calls with their responses
  clientMutationId: String

  # The created tax rate
  taxRate: TaxRate!
}

# The input for updating a tax rate. Note that missing values will cause the field to be cleared, so
# send all optional fields with every request unless they aren't currently set or you intend to clear them.
input UpdateTaxRateInput {
  # An optional string identifying the mutation call, which will be returned in the response payload
  clientMutationId: String

  # An optional country code to limit where this tax is applied based on destination address
  country: String

  # An optional postal code to limit where this tax is applied based on destination address
  postal: String

  # The tax rate. For example, 0.05 for a 5% sales tax.
  rate: Float!

  # An optional region (e.g., state) to limit where this tax is applied based on destination address
  region: String

  # Shop ID
  shopId: ID!

  # Whether the `country`, `postal`, and `region` filters apply to the origin address or the destination address
  sourcing: TaxSource

  # An optional tax code, to apply this tax rate to only products that have this tax code
  taxCode: String

  # ID of the tax rate you want to update
  taxRateId: ID!
}

# The response from the `updateTaxRate` mutation
type UpdateTaxRatePayload {
  # The same string you sent with the mutation params, for matching mutation calls with their responses
  clientMutationId: String

  # The updated tax rate
  taxRate: TaxRate!
}

# Describes the input for removing a tax rate
input DeleteTaxRateInput {
  # An optional string identifying the mutation call, which will be returned in the response payload
  clientMutationId: String

  # Shop ID
  shopId: ID!

  # The tax rate ID
  taxRateId: ID!
}

# The response from the `deleteTaxRate` mutation
type DeleteTaxRatePayload {
  # The same string you sent with the mutation params, for matching mutation calls with their responses
  clientMutationId: String

  # The deleted tax rate
  taxRate: TaxRate!
}

# Input for the `createNavigationItem` mutation
input CreateNavigationItemInput {
  # An optional string identifying the mutation call, which will be returned in the response payload
  clientMutationId: String

  # The navigation item to create
  navigationItem: NavigationItemInput!
}

# NavigationItem input
input NavigationItemInput {
  # The draft/unpublished data for this navigation item
  draftData: NavigationItemDataInput

  # An object storing additional metadata about the navigation item (such as its related tag)
  metadata: JSONObject

  # Shop ID of the navigation item
  shopId: ID!
}

# NavigationItemData input
input NavigationItemDataInput {
  # CSS class names to add to the menu item for display
  classNames: String

  # The content for the navigation item, in one or more languages
  content: [NavigationItemContentInput]

  # Whether the provided URL is relative or external
  isUrlRelative: Boolean

  # Whether the navigation item should trigger a new tab/window to open when clicked
  shouldOpenInNewWindow: Boolean

  # The URL for the navigation item to link to
  url: String
}

# NavigationItem content input
input NavigationItemContentInput {
  # The language of the piece of navigation content
  language: String!

  # The translated value, in plain text or markdown
  value: String
}

# Response payload for the `createNavigationItem` mutation
type CreateNavigationItemPayload {
  # The same string you sent with the mutation params, for matching mutation calls with their responses
  clientMutationId: String

  # The created navigation item
  navigationItem: NavigationItem
}

# Input for the `createNavigationTree` mutation
input CreateNavigationTreeInput {
  # An optional string identifying the mutation call, which will be returned in the response payload
  clientMutationId: String

  # The draft navigation items that make up this tree
  draftItems: [NavigationTreeItemInput]

  # The name of the tree, for operator display purposes
  name: String!

  # The ID of the shop this navigation tree belongs to
  shopId: ID!
}

# NavigationTree item input
input NavigationTreeItemInput {
  # Whether the navigation item should display its children
  expanded: Boolean

  # Whether the navigation item should be hidden from customers
  isPrivate: Boolean

  # Whether the navigaton item is a secondary navigation item
  isSecondary: Boolean

  # Whether the navigation ttem should shown in query results for customers and admins
  isVisible: Boolean

  # The child navigation items
  items: [NavigationTreeItemInput]

  # The ID of the navigation item
  navigationItemId: ID!
}

# Response payload for the `createNavigationTree` mutation
type CreateNavigationTreePayload {
  # The same string you sent with the mutation params, for matching mutation calls with their responses
  clientMutationId: String

  # The created navigation tree
  navigationTree: NavigationTree!
}

# Input for the `deleteNavigationItem` mutation
input DeleteNavigationItemInput {
  # An optional string identifying the mutation call, which will be returned in the response payload
  clientMutationId: String

  # The ID of the navigation item to delete
  id: ID!

  # The ID of the shop navigation item belongs to
  shopId: ID!
}

# Response payload for the `deleteNavigationItem` mutation
type DeleteNavigationItemPayload {
  # The same string you sent with the mutation params, for matching mutation calls with their responses
  clientMutationId: String

  # The deleted navigation item
  navigationItem: NavigationItem
}

# Input for the `publishNavigationChanges` mutation
input PublishNavigationChangesInput {
  # An optional string identifying the mutation call, which will be returned in the response payload
  clientMutationId: String

  # The ID of the navigation tree
  id: ID!

  # Shop ID of the navigation tree
  shopId: ID!
}

# Response payload for the `publishNavigationChanges` mutation
type PublishNavigationChangesPayload {
  # The same string you sent with the mutation params, for matching mutation calls with their responses
  clientMutationId: String

  # The navigation tree with updated items
  navigationTree: NavigationTree
}

# Input for the `updateNavigationItem` mutation
input UpdateNavigationItemInput {
  # An optional string identifying the mutation call, which will be returned in the response payload
  clientMutationId: String

  # The ID of the navigation item to update
  id: ID!

  # The field updates to apply
  navigationItem: NavigationItemInput!

  # The ID of the shop navigation item belongs to
  shopId: ID!
}

# Response payload for the `updateNavigationItem` mutation
type UpdateNavigationItemPayload {
  # The same string you sent with the mutation params, for matching mutation calls with their responses
  clientMutationId: String

  # The updated navigation item
  navigationItem: NavigationItem
}

# Input for the `updateNavigationTree` mutation
input UpdateNavigationTreeInput {
  # An optional string identifying the mutation call, which will be returned in the response payload
  clientMutationId: String

  # The ID of the navigation tree to update
  id: ID!

  # The field updates to apply
  navigationTree: NavigationTreeInput!

  # The ID of the shop navigation item belongs to
  shopId: ID!
}

# NavigationTree input
input NavigationTreeInput {
  # The draft navigation items that make up this tree
  draftItems: [NavigationTreeItemInput]

  # The name of the tree, for operator display purposes
  name: String
}

# Response payload for the `updateNavigationTree` mutation
type UpdateNavigationTreePayload {
  # The same string you sent with the mutation params, for matching mutation calls with their responses
  clientMutationId: String

  # The updated navigation tree
  navigationTree: NavigationTree
}

# Input for the `generateSitemaps` mutation
input GenerateSitemapsInput {
  # An optional string identifying the mutation call, which will be returned in the response payload
  clientMutationId: String

  # The ID of the shop to generate sitemap for
  shopId: ID!
}

# Response for the `generateSitemaps` mutation
type GenerateSitemapsPayload {
  # The same string you sent with the mutation params, for matching mutation calls with their responses
  clientMutationId: String

  # Whether the sitemap generation job was successfully scheduled
  wasJobScheduled: Boolean!
}

input CreateUserInput {
  username: String
  email: String
  password: String
}

type CreateUserResult {
  userId: ID
  loginResult: LoginResult
}

type LoginResult {
  sessionId: String
  tokens: Tokens
  user: User
}

type Tokens {
  refreshToken: String
  accessToken: String
}

input TwoFactorSecretKeyInput {
  ascii: String
  base32: String
  hex: String
  qr_code_ascii: String
  qr_code_hex: String
  qr_code_base32: String
  google_auth_qr: String
  otpauth_url: String
}

input ImpersonationUserIdentityInput {
  userId: String
  username: String
  email: String
}

type ImpersonateReturn {
  authorized: Boolean
  tokens: Tokens
  user: User
}

input AuthenticateParamsInput {
  access_token: String
  access_token_secret: String
  provider: String
  password: String
  user: UserInput
  code: String
  token: String
}

input UserInput {
  id: ID
  email: String
  username: String
}

# Subscriptions allow you to request to get updated data whenever it changes
type Subscription {
  # A test subscription that returns an incremented number every 1 second for 10 seconds
  tick: Int!
}

# Represents a catalog item that displays some non-product content
type CatalogItemContent implements CatalogItem & Node {
  # The CatalogItemProduct ID
  _id: ID!

  # The date and time at which this CatalogItem was first created
  createdAt: DateTime!

  # The shop to which this catalog belongs
  shop: Shop!

  # The date and time at which this CatalogItem was last updated
  updatedAt: DateTime!
}

# One product catalog for a particular shop
type Catalog implements Node {
  # The Catalog ID
  _id: ID!

  # The date and time at which this Catalog was first created
  createdAt: DateTime!

  # The shop to which this catalog belongs
  shop: Shop!

  # The date and time at which this Catalog was last updated
  updatedAt: DateTime!
}
